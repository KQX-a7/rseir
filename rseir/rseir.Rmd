---
title: "rpyseir prototype"
author: "QingXuan Kong"
date: "2020/8/27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Reminders(20200920):
1.To run the program, first run "## the functions" chunk to load the functions, then run "## the main script".

2.To change the parameters, you could change the corresponding <- assign in "## the main script".

3.To change or add the state, change the state <- c("IL") assign in "## the main script"

4.the SEIRD variables output is in outputs/SEIRD_data/.

5.If you are looking for plots for a specific state, go to "outputs/plots_by_state". If you are looking for plots for a specific type, go to "outputs/plots".

6.The observed dataset is in the input folder. Their are downloaded on 20200919.

"US_timeseries.csv" is from https://github.com/covid-projections/covid-data-model/blob/master/data/timeseries.csv . 

"CA_timeseries.csv" is from https://resources-covid19canada.hub.arcgis.com/datasets/provincial-daily-totals. 

To update them, download the corresponding csv file, rename it and place it in the input folder .

7.I have add a "force correction" for negative increase, so you don't need to fix it in the observed dataset. Any negative increase value will be set as its previous value.
 
8.the result of one-phases setup is bad, might have something to do with the intial value or the limitations of the data-driven parameters.


## the functions
```{r}
library(tidyverse)
library(deSolve)
library(glue)

# ## create the state info table with population and fip
# get_state_info <- function()
# {
#   ## create the population and fip obj
#   raw_population <-
#     read_csv("inputs/populations.csv", col_types = "c-i")
#   raw_state_and_fips <-
#     read_csv("inputs/state_and_fips.csv", col_types = "cccc")
#   # VI and PR can't be found in the pyseir output
#   
#   state_info <-
#     left_join(raw_population,
#               raw_state_and_fips,
#               by = c("state" = "Alpha code")) %>%
#     filter(!str_detect(Status, pattern = "Minor")) %>%
#     rename("alpha_code" = "state", "dirty_fip" = "Numeric code") %>%
#     mutate(fip = ifelse(nchar(dirty_fip) == 2, dirty_fip, paste0("0", dirty_fip))) %>%
#     select(Name, alpha_code, fip, population) %>%
#     arrange(Name)
#   return(state_info)
# }


#### rpyseir
rpyseir <- function()
{
  ## run for all state setup
  ### PENDING: check state and all_states
  if (all_states)
    state <- state_info$alpha_code
  
  ### PENDING: check and report initial_dd_value
  
  for (state_ac in state)
  {
    sampling_para <- get_sampling_parameters(state_ac, n_sample)
    observed_data_kit <-
      parse_observed_data_for_score_calculation(state_ac)
    
    ## the optimizer
    ### notice: Minimization function is different. nlm doesn't take limits, try optim?
    print(glue("optim for {state_ac} begin"))
    opt_res <-
      optim(
        par = initial_dd_parameter,
        fn = score_function,
        gr = NULL,
        s_para = sampling_para,
        obs_data_kit = observed_data_kit,
        method = "L-BFGS-B",
        lower = dd_parameter_lower,
        upper = dd_parameter_upper
      )
    
    ## report the optimization result
    if (opt_res$convergence == 0)
    {
      print(glue("optim for {state_ac} is successful"))
      print(glue("after {opt_res$counts[1]} calls to the score function"))
      print("**************")
    }
    else if (opt_res$convergence == 1)
    {
      print(glue("optim for {state_ac} is stopped"))
      print(glue("after {opt_res$counts[1]} calls to the score function"))
      print(glue("message from optim: {opt_res$message}"))
      print("The optim result should be reasonable. Change the initial value or increase the iteration limit might improve the optim result.")
      print("**************")
    }
    else
    {
      print(glue("optim for {state_ac} encounter error, error code: {opt_res$convergence}"))
      print(glue("after {opt_res$counts[1]} calls to the score function"))
      print(glue("message from optim: {opt_res$message}"))
      print("**************")
    }
    
    saveRDS(opt_res, 
            file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_opt_res.rds"))
    saveRDS(sampling_para,
            file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_sampling_para.rds"))
    saveRDS(observed_data_kit,
            file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_observed_data_kit.rds"))
    SEIRD_pred <-
      final_result_generation(
        state_ac,
        dd_para = opt_res$par,
        s_para = sampling_para,
        obs_data_kit = observed_data_kit
      )
    write_csv(SEIRD_pred,
              path = glue("outputs/{country}/SEIRD_data/{country}_{state_ac}_SEIRD_pred.csv"))
    saveRDS(SEIRD_pred,
            file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_SEIRD_pred.rds"))
    
    ### notice: the make_plots function is "separate" from the rest of rpyseir
    ### It use the rds file as input instead of the parameter input
    ### so it could run individually, as long as you have run rpyseir for your chosen state for once and generate the rds files
    ### This will come in handy if you want to change the label of my plot
    ### In that case, you can just tweak make_plot(state_ac) and run it, without running rpyseir() again
    make_plots(state_ac)
  }
}


## generated the sampling parameters
get_sampling_parameters <- function(state_ac, n_sample = 5000)
{
  # most of the comments in this function are from the origin pysier, except for those start with "### notice"
  # I keep them because some of them seems to explain how covid-act-now team get the parameters/distributions.
  # Though I didn't dig into them.
  
  rnorm_min0 <- function(mu, sd)
  {
    return(abs(rnorm(n_sample, mu, sd)))
  }
  
  # this is used to calculate another parameter
  hospitalization_rate_general = rnorm_min0(mu = 0.02, sd = 0.01)
  
  para_list <- list(
    # basis information
    population =
      state_info$population[which(state_info$alpha_code == state_ac)],
    state_name = state_info$Name[which(state_info$alpha_code == state_ac)],
    
    ### notice: the SEIRD initial value setup is moved to get_SEIRD_timeseries()
    
    R0_hospital = mean(runif(n_sample, min = 3.2 / 6, max = 4 / 6)),
    
    # For now we have disabled this bucket and lowered rates of other
    # boxes accordingly. Since we were not modeling different contact
    # rates, this has the same result
    
    ### notice: asymptomatic is not implemented. Comment out corresponding parameters.
    # fraction_asymptomatic = 0
    
    # These parameters produce an IFR ~0.0065 if we had infinite
    # capacity, and about ~0.0125 with capacity constraints imposed
    
    hospitalization_rate_general = mean(hospitalization_rate_general),
    hospitalization_rate_icu = mean(rnorm_min0(mu = 0.30, sd = 0.05) * hospitalization_rate_general),
    
    ### notice: ventilator gourp is merged with I3. Comment out corresponding parameters.
    fraction_icu_requiring_ventilator = mean(rnorm_min0(mu = 0.6, sd = 0.1)),
    sigma = mean(1 / rnorm_min0(mu = 3.0, sd = 0.86)),
    # Sigma = Imperial college - 2 days since that is expected infectious period.
    delta = mean(1 / rgamma(n_sample, shape = 6.0, scale = 1)),
    # Delta = Kind of based on imperial college + CDC digest.
    delta_hospital = mean(1 / rgamma(n_sample, shape = 8.0, scale = 1)),
    # delta_hospital Kind of based on imperial college + CDC digest.
    
    ### notice: asymptomatic is not implemented. Comment out corresponding parameters.
    # kappa = 1,
    # Contact rate for asympt
    # gamma = (1 - fraction_asymptomatic) is not implemented
    # https://www.cdc.gov/coronavirus/2019-ncov/hcp/clinical-guidance-management-patients.html
    
    symptoms_to_hospital_days = mean(rnorm_min0(mu = 6.0, sd = 1.5)),
    hospitalization_length_of_stay_general = mean(rnorm_min0(mu = 7.0, sd = 1)),
    # hospitalization_length_of_stay_icu_avg=8.6,  # Weighted avg of icu w & w/o
    hospitalization_length_of_stay_icu = mean(rnorm_min0(mu = 8.0, sd = 3)),
    
    ### notice: ventilator gourp is merged with I3. Comment out corresponding parameters.
    hospitalization_length_of_stay_icu_and_ventilator =
      mean(rnorm_min0(mu = 9.0, sd = 3)),
    
    # if you assume the ARDS population is the group that would die
    # w/o ventilation, this would suggest a 20-42% mortality rate
    # among general hospitalized patients w/o access to ventilators:
    # “Among all patients, a range of 3% to 17% developed ARDS
    # compared to a range of 20% to 42% for hospitalized patients
    # and 67% to 85% for patients admitted to the ICU.1,4-6,8,11”
    # 10% Of the population should die at saturation levels. CFR
    # from Italy is 11.9% right now, Spain 8.9%.  System has to
    # produce,
    
    ### notice: the saturation mechanics is not inplemented. Comment out corresponding parameters.
    # mortality_rate_no_general_beds = mean(rnorm_min0(mu = 0.10, sd = 0.01)),
    # mortality_rate_no_ICU_beds = 1.0
    mortality_rate_from_hospital = 0.05,
    mortality_rate_from_ICU = mean(rnorm_min0(mu = 0.5, sd = 0.05))
    ### notice: ventilator gourp is merged with I3. Comment out corresponding parameters.
    # mortality_rate_from_ICUVent = 0.70,
    
    ### notice: the saturation mechanics is not inplemented. Comment out corresponding parameters.
    # beds_general=self.beds * (1 - self.bed_utilization) * 2.07
    # 60% utliization, no scaling...
    # TODO.. Patch this After Issue 132
    # beds_ICU=(1 - self.icu_utilization) * self.icu_beds,
    # No scaling, 75% utilization...
    # hospital_capacity_change_daily_rate=1.05,
    # max_hospital_capacity_factor=2.07,
    # initial_hospital_bed_utilization=0.6,
    # Rubinson L, Vaughn F, Nelson S, et al. Mechanical ventilators
    # in US acute care hospitals. Disaster Med Public Health Prep.
    # 2010;4(3):199-206. http://dx.doi.org/10.1001/dmp.2010.18.
    # 0.7 ventilators per ICU bed on average in US ~80k Assume
    # another 20-40% of 100k old ventilators can be used. = 100-120
    # for 100k ICU beds
    # TODO: Update this if possible by county or state. The ref above has state estimates
    # Staff expertise may be a limiting factor:
    # https://sccm.org/getattachment/About-SCCM/Media-Relations/Final-Covid19-Press-Release.pdf?lang=en-US
    # TODO: Patch after #133
    # ventilators=self.icu_beds * np.random.uniform(low=0.9, high=1.1),
  )
  
  return (para_list)
}



## load historical/observed data and extract the value needed for score calculation
parse_observed_data_for_score_calculation <- function(state_ac)
{
  if (country == "US")
  {
    raw_timeseries <-
      read_csv("inputs/US_timeseries.csv", col_types = "cDcccciiiiiiiiiiiiii")
    target_timeseries <- raw_timeseries %>%
      filter(
        aggregate_level == "state",
        state == state_ac ,
        date < last_date_with_available_data ,
        date > reference_date
      ) %>%
      select(fips,
             state,
             date,
             cases,
             deaths,
             cumulative_hospitalized,
             current_hospitalized)
    
    saveRDS(target_timeseries,
            file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_target_obs.rds"))
    
    target_timeseries <- target_timeseries %>%
      mutate(days_to_ref = as.integer(date - reference_date)) %>%
      mutate(cases_increase = cases - lag(cases, n = 1)) %>%
      mutate(deaths_increase = deaths - lag(deaths, n = 1)) %>%
      mutate(hospitalized_increase = cumulative_hospitalized - lag(cumulative_hospitalized, n = 1)) %>%
      select(
        state,
        days_to_ref,
        cases_increase,
        deaths_increase,
        hospitalized_increase,
        current_hospitalized
      )
    
  }
  else if (country == "CA")
  {
    raw_timeseries <-
      read_csv("inputs/CA_timeseries.csv",
               col_types = "icciciiiiiiiiiiiii")
    
    target_timeseries <- raw_timeseries %>%
      mutate(date = parse_date(str_sub(SummaryDate, end = 10))) %>%
      rename(
        state = Abbreviation,
        cases = TotalCases,
        deaths = TotalDeaths,
        current_hospitalized = TotalHospitalized
      ) %>%
      filter(state == state_ac ,
             date < last_date_with_available_data ,
             date > reference_date) %>%
      select(state,
             date,
             cases,
             deaths,
             current_hospitalized,
             DailyTotals,
             DailyDeaths)
    
    saveRDS(target_timeseries,
            file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_target_obs.rds"))
    target_timeseries <- target_timeseries %>%
      mutate(days_to_ref = as.integer(date - reference_date)) %>%
      rename(cases_increase = DailyTotals) %>%
      rename(deaths_increase = DailyDeaths) %>%
      select(state,
             days_to_ref,
             cases_increase,
             deaths_increase,
             current_hospitalized)
  }

  try(if (!country %in% c("US","CA")) {
    stop(glue("Program for {country} is not implemented yet."))
  }
  )
  
  ## extract non-na row
  with(target_timeseries,
       {
         I1_obsdays <- days_to_ref[!is.na(cases_increase)]
         I1_obs <- cases_increase[!is.na(cases_increase)]
         D_obsdays <- days_to_ref[!is.na(deaths_increase)]
         D_obs <- deaths_increase[!is.na(deaths_increase)]
         
         # hospitalization is a bit tricky
         # there are two column for it, "cumulative" and "current"
         # generally "current" seems to be in better quality, with less na
         # And there are some obvious mistake in "cumulative", such as decreasing, being less than current,  being negative
         # so "current" is preferred, unless "cumulative" has less na, always increase and stay positive.
         
         if (country == "US") {
           if (mean(is.na(hospitalized_increase)) < mean(is.na(current_hospitalized)) &
               !any(hospitalized_increase < 0, na.rm = TRUE))
           {
             hosp_flag <- "cumulative"
             hosp_obsdays <-
               days_to_ref[!is.na(hospitalized_increase)]
             hosp_obs <-
               hospitalized_increase[!is.na(hospitalized_increase)]
           }
           else
           {
             hosp_flag <- "current"
             hosp_obsdays <- days_to_ref[!is.na(current_hospitalized)]
             hosp_obs <-
               current_hospitalized[!is.na(current_hospitalized)]
           }
         }
         
         if (country == "CA") {
           hosp_flag <- "current"
           hosp_obsdays <-
             days_to_ref[!is.na(current_hospitalized)]
           hosp_obs <-
             current_hospitalized[!is.na(current_hospitalized)]
         }
         

         
         ## check whether there are negative "increase"
         if (any(I1_obs < 0))
         {
           print(paste0("negative observed data: I1 of ", state_ac))
           print("replace the negative value with its previous value")
           I1_obs[which(I1_obs<0)] <- I1_obs[which(I1_obs<0)-1]
         }
         if (any(D_obs < 0))
         {
           print(paste0("negative observed data: D of ", state_ac))
           print("replace the negative value with its previous value")
           D_obs[which(D_obs<0)] <- D_obs[which(D_obs<0)-1]
         }
         if (any(hosp_obs < 0))
         {
           print(paste0("negative observed data: hosp ", hosp_flag, " of ", state_ac))
           print("replace the negative value with its previous value")
           hosp_obs[which(hosp_obs<0)] <- hosp_obs[which(hosp_obs<0)-1]
         }

         
         
         
         # chi-square score need standard deviance for each observation
         # don't know why it should be calculation in this way
         # the I1 and hosp std is multiplied by 0.5. This is equal to multiply their chi-square score by 4. It is supposed to "control chi2 mix between hospitalization and deaths"
         # The following comments are the origin comments of std calcualtion from pyseir
         # Generate the errors on the observations.
         # Here we throw out a few assumptions to plant a flag...
         # 1. Systematic errors dominate and are likely of order 50% at least based
         # on 100% undercounting of deaths and hospitalizations in many places.
         # Though we account for static undercounting by letting case and hosp
         # counts float, so lets assume the error is a bit smaller for now.
         # 2. 100% is too small for 1 case count or mortality.. We should be much
         #    more confident in large numbers of observations
         # 3. TODO: Deal with this fact.. Actual observations are lower bounds.
         #          Need asymmetric errors.
         # As an error model, absolutes are less important to our problem compared
         # to getting relative error scaling reasonably done. This is not true if
         # drawing contours and confidence intervals which is why we choose large
         # conservative errors to overestimate the uncertainty.
         # As a relative scaling model we think about Poisson processes and scale
         # the errors in the following way:
         # 1. Set the error of the largest observation to 100% of its value.
         # 2. Scale all other errors based on sqrt(value) * sqrt(max_value)
         I1_std <- sqrt(I1_obs) * sqrt(max(I1_obs)) * 0.5
         hosp_std <- sqrt(hosp_obs) * sqrt(max(hosp_obs)) * 0.5
         D_std <- sqrt(D_obs) * sqrt(max(D_obs))
         # if the observered value is small, increase its standard deviation to make it less influential.
         I1_std <- ifelse(I1_obs<5,3*I1_std,I1_std)
         hosp_std <- ifelse(hosp_obs<5,3*hosp_std,hosp_std)
         D_std <- ifelse(D_obs<5,3*D_std,D_std)
         # fix 0 standard deviation
         I1_std <- ifelse(I1_std==0,3,I1_std)
         hosp_std <- ifelse(hosp_std==0,3,hosp_std)
         D_std <- ifelse(D_std==0,3,D_std)
         
         return(
           list(
             I1_obsdays = I1_obsdays,
             I1_obs = I1_obs,
             I1_std = I1_std,
             D_obsdays = D_obsdays,
             D_obs = D_obs,
             D_std = D_std,
             hosp_flag = hosp_flag,
             hosp_obsdays = hosp_obsdays,
             hosp_obs = hosp_obs,
             hosp_std = hosp_std
           ))
       })
  
}




## The score function
score_function <- function(dd_para, s_para, obs_data_kit)
{
  
  param_set <- s_para
  ## parse the input parameter
  param_set$log10_I_initial <- 1
  test_fraction <- dd_para[1]
  hosp_fraction <- dd_para[2]
  t0 <- dd_para[3]
  
  supt_para <- dd_para[-(1:3)]
  
  # this beta1t is a vector storing the beta1 value on day 1:total_days
  # it represent/determined the number of phases
  param_set$beta1t <- build_beta1t(supt_para, s_para$delta)
  
  SEIRD_pred <- get_SEIRD_timeseries(param_set)
  # calculate the chi-square score
  with(obs_data_kit, {
    # calculate increase from cumulative value
    I1_increase <-
      SEIRD_pred$cumulative_I1[-1] - lag(SEIRD_pred$cumulative_I1, n = 1)[-1]
    hosp_increase <-
      SEIRD_pred$cumulative_I2_I3[-1] - lag(SEIRD_pred$cumulative_I2_I3, n = 1)[-1]
    D_increase <-
      SEIRD_pred$D[-1] - lag(SEIRD_pred$D, n = 1)[-1]
    # get the prediction value where there are observed data.
    
    I1_pred <-
      approx(
        x = (1:total_days) + t0,
        y = I1_increase,
        xout = I1_obsdays,
        yleft = 0,
        yright = 0
      )$y*test_fraction
    
    D_pred <-
      approx(
        x = (1:total_days) + t0,
        y = D_increase,
        xout =  D_obsdays,
        yleft = 0,
        yright = 0
      )$y
    
    if (hosp_flag == "cumulative")
    {
      hosp_pred <-
        approx(
          x = (1:total_days) + t0,
          y = hosp_increase,
          xout =  hosp_obsdays,
          yleft = 0,
          yright = 0
        )$y*hosp_fraction
    }
    else if (hosp_flag == "current")
    {
      hosp_pred <-
        approx(
          x = (0:total_days) + t0,
          y = (SEIRD_pred$I2 + SEIRD_pred$I3),
          xout = hosp_obsdays,
          yleft = 0,
          yright = 0
        )$y*hosp_fraction
    }
    
    # calculation the chi-square score
    chi2_I1 <- sum((I1_pred - I1_obs) ^ 2 / I1_std ^ 2)
    chi2_D <- sum((D_pred - D_obs) ^ 2 / D_std ^ 2)
    chi2_hosp <- sum((hosp_pred - hosp_obs) ^ 2 / hosp_std ^ 2)
    
    
    ### notice: no_data_penalty is not implemented
    # return(chi2_I1 + chi2_D + chi2_hosp)
    return(chi2_I1+ chi2_hosp)
  })
}




## Generate the beta1t
build_beta1t <- function(supt_para, delta)
{
  # 1:total_days is the days_from_t0_index
  ### notice: no implementation for eps_future,so no cap on eps2
  if (number_of_phase == 1)
  {
    R0 <- supt_para[1]
    
    beta1t <- R0 * delta * rep(1, (total_days+1))
    return(beta1t)
  }
  else if (number_of_phase == 2)
  {
    R0 <- supt_para[1]
    phase1_duration <- supt_para[2]
    eps1 <- supt_para[3]
    
    beta1t <-
      approx(
        x = c(1,
              phase1_duration,
              phase1_duration + 14),
        y = R0 * delta * c(1, 1, eps1),
        xout = 1:(total_days+1),
        yleft = R0 * delta * 1,
        yright = R0 * delta * eps1
      )
    return(beta1t$y)
  }
  else if (number_of_phase == 3)
  {
    R0 <- supt_para[1]
    phase1_duration <- supt_para[2]
    eps1 <- supt_para[3]
    phase2_duration <- supt_para[4]
    eps2 <- supt_para[5]
    
    beta1t <-
      approx(
        x = c(
          1,
          phase1_duration,
          phase1_duration + 14,
          phase1_duration + 14 + phase2_duration,
          phase1_duration + 14 + phase2_duration + 14
        ),
        y = R0 * delta * c(1, 1, eps1, eps1, eps2),
        xout = 1:(total_days+1),
        yleft = R0 * delta * 1,
        yright = R0 * delta * eps2
      )
    return(beta1t$y)
  }
  
  try(if (!number_of_phase %in% c(1,2,3)) {
    stop(paste0(number_of_phase, " phases is not implemented yet."))
  })
}




## the SEIRD model
get_SEIRD_timeseries <- function(param_set)
{
  # Load up some number of initial exposed so the initial flow into infected is stable.(origin pyseir comment)
  steady_state_exposed_to_infected_ratio <- 1.2
  I1_initial <- 10 ^ param_set$log10_I_initial
  E_initial <- I1_initial * steady_state_exposed_to_infected_ratio
  S_initial <- param_set$population - I1_initial - E_initial
  
  init_vals <- c(
    S = S_initial,
    E = E_initial,
    I1 = I1_initial,
    I2 = 0,
    I3 = 0,
    R = 0,
    D = 0,
    # these two stores the values that might be needed in the score function
    # we are not part of the SEIRD model, just something calculated from the SEIRD variables.
    cumulative_I1 = I1_initial,
    cumulative_I2_I3 = 0
  )
  
  result <-
    ode(y = init_vals,
        times = 0:total_days,
        func = SEIRD_timestep,
        param_set)
  result <- as.data.frame(result)
  # somehow the init_vals mess up the column name of the result. Fix it.
  names(result)[c(2, 3, 4, 9)] <- c("S", "E", "I1", "cumulative_I1")
  return(result)
}

SEIRD_timestep <- function(t, current_vals, param_set)
{
  S <- current_vals[1]
  E <- current_vals[2]
  I1 <- current_vals[3]
  I2 <- current_vals[4]
  I3 <- current_vals[5]
  R <- current_vals[6]
  D <- current_vals[7]
  
  # these two stores the values that might be needed in the score function
  cumulative_I1 = current_vals[8]
  cumulative_I2_I3 = current_vals[9]
  
  with(param_set, {
    number_exposed <-
      beta1t[t+1] * S / population * I1 + R0_hospital * delta_hospital * S / population *
      (I2 + I3)
    dS <- -number_exposed
    
    exposed_and_symptomatic <- E * sigma
    dE <- number_exposed - exposed_and_symptomatic
    
    ### notice: the saturation mechanics is not inplemented
    infected_and_recovered_without_hospital <- I1 * delta
    infected_and_to_I2 <-
      I1 * (hospitalization_rate_general - hospitalization_rate_icu) / symptoms_to_hospital_days
    infected_and_to_I3 <-
      I1 * hospitalization_rate_icu / symptoms_to_hospital_days
    dI1 <-
      exposed_and_symptomatic - infected_and_recovered_without_hospital - infected_and_to_I2 - infected_and_to_I3
    
    ### notice: the saturation mechanics is not inplemented.
    # basically, the outflow of I2 and I3 is current_val/length_of_stay
    # mortality_rate% of them die, the rest is considered recovered.
    died_from_I2 <-
      I2 * mortality_rate_from_hospital / hospitalization_length_of_stay_general
    died_from_I3 <-
      I3 * mortality_rate_from_ICU / hospitalization_length_of_stay_icu
    recovered_from_I2 <-
      I2 * (1 - mortality_rate_from_hospital) / hospitalization_length_of_stay_general
    recovered_from_I3 <-
      I3 * (1 - mortality_rate_from_ICU) / hospitalization_length_of_stay_icu
    dI2 <- infected_and_to_I2 - died_from_I2 - recovered_from_I2
    dI3 <- infected_and_to_I3 - died_from_I3 - recovered_from_I3
    dR <-
      infected_and_recovered_without_hospital + recovered_from_I2 + recovered_from_I3
    dD <- died_from_I2 + died_from_I3
    
    # these two stores the values that might be needed in the score function
    # only add inflow
    dcumulative_I1 <- exposed_and_symptomatic
    dcumulative_I2_I3 <-
      infected_and_to_I2 + infected_and_to_I3
    
    result <-
      c(dS, dE, dI1, dI2, dI3, dR, dD, dcumulative_I1, dcumulative_I2_I3)
    
    return(list(result))
  })
}




## calculate the final sEIRD data and make the plot
final_result_generation <- function(state_ac,dd_para,s_para,obs_data_kit)
{
  param_set <- s_para
  ## parse the input parameter
  param_set$log10_I_initial <- 1
  test_fraction <- dd_para[1]
  hosp_fraction <- dd_para[2]
  t0 <- dd_para[3]
  
  # this beta1t is a vector storing the beta1 value on day 1:total_days
  # it represent/determined the number of phases
  supt_para <- dd_para[-(1:3)]
  param_set$beta1t <- build_beta1t(supt_para, s_para$delta)
  
  SEIRD_pred <- get_SEIRD_timeseries(param_set)
  
  # calculate the increase
  I1_increase <-
    SEIRD_pred$cumulative_I1[-1] - lag(SEIRD_pred$cumulative_I1, n = 1)[-1]
  hosp_increase <-
    SEIRD_pred$cumulative_I2_I3[-1] - lag(SEIRD_pred$cumulative_I2_I3, n = 1)[-1]
  D_increase <-
    SEIRD_pred$D[-1] - lag(SEIRD_pred$D, n = 1)[-1]
  
  # finialize and save the SEIRD prediction dataset
  SEIRD_pred <- SEIRD_pred %>%
    mutate(
      date = reference_date + t0 + time,
      I1_increase = c(0, I1_increase),
      hosp_increase = c(0, hosp_increase),
      D_increase = c(0, D_increase)
    ) %>% 
    mutate(
      I1_tested = I1 * test_fraction,
      I1_increase_tested = I1_increase * test_fraction,
      cumulative_I1_tested = cumulative_I1 * test_fraction
    ) %>% 
    rename(days_to_t0=time) %>% 
    select(date,days_to_t0,everything())
  
  return(SEIRD_pred)
}

make_plots <- function(state_ac)
{
  ### notice: the make_plots function is "separate" from the rest of rpyseir
  ### It use the rds file as input instead of the parameter input
  ### so it could run individually, as long as you have run rpyseir for your chosen state for once and generate the rds files
  ### This will come in handy if you want to change the label of my plot
  ### In that case, you can just tweak make_plot(state_ac) and run it, without running rpyseir() again
  
  ## reload the rds files
  dd_para <-
    readRDS(file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_opt_res.rds"))$par
  opt_res <-
    readRDS(file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_opt_res.rds"))
  s_para <-
    readRDS(file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_sampling_para.rds"))
  obs_data_kit <-
    readRDS(file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_observed_data_kit.rds"))
  SEIRD_pred <-
    readRDS(file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_SEIRD_pred.rds"))
  target_obs <- 
    readRDS(file = glue("outputs/{country}/temp_rds/{country}_{state_ac}_target_obs.rds"))
  
  
  test_fraction <- dd_para[1]
  hosp_fraction <- dd_para[2]
  t0 <- dd_para[3]
  beginning_of_future <-
    min(reference_date + max(obs_data_kit$I1_obsdays),
        last_date_with_available_data)
  
  ## need a function to add the vertical lines bases on the number of phases
  Add_timestamp_vline <- function(temp_plot,skip=FALSE,for_beta1t=FALSE)
  {
    temp_plot <- temp_plot +
      geom_vline(xintercept = reference_date + t0, color = "black") +
      annotate("text",
               x = reference_date + t0,
               y = 0,
               label = "t0",size = 3) +
      geom_vline(xintercept = beginning_of_future, color = "black") +
      annotate("text",
               x = beginning_of_future,
               y = 0,
               label = "pred_begin",size = 3)
    ## some plots don't need to add the phase stuff, so here is a way to skip them
    if(skip==TRUE)
    {
      return(temp_plot)
    }
    
    ## check number_of_phase and add vertical lines where the phase is changed
    try(if (!number_of_phase %in% c(1, 2, 3)) {
      stop(paste0(number_of_phase, " phases is not implemented yet."))
    }
    )
    
    if (number_of_phase == 2)
    {
      phase1_duration <- dd_para[5]
      eps1 <- dd_para[6]
      phase1_end <- reference_date + t0 + phase1_duration
      temp_plot <- temp_plot +
        geom_vline(xintercept = phase1_end, color = "black") +
        annotate("text",
                 x = phase1_end,
                 y = 0,
                 label = "p1_end",size = 3)
      if(for_beta1t==TRUE)
      {
        temp_plot <- temp_plot +
          annotate("text",
                 x = phase1_end+14,
                 y = eps1,
                 label = paste0("eps1=",eps1),size = 3)
      }
    }
    else if (number_of_phase == 3)
    {
      phase1_duration <- dd_para[5]
      phase1_end <- reference_date + t0 + phase1_duration
      eps1 <- dd_para[6]
      phase2_duration <- dd_para[7]
      phase2_end <-
        reference_date + t0 + phase1_duration + days_between_phases + phase2_duration
      eps2 <- dd_para[8]
      temp_plot <- temp_plot +
        geom_vline(xintercept = phase1_end, color = "black") +
        annotate("text",
                 x = phase1_end,
                 y = 0,
                 label = "p1_end",size = 3) +
        geom_vline(xintercept = phase2_end, color = "black") +
        annotate("text",
                 x = phase2_end,
                 y = 0,
                 label = "p2_end",size = 3)
      if (for_beta1t == TRUE)
      {
        temp_plot <- temp_plot +
          annotate(
            "text",
            x = phase1_end+14,
            y = eps1,
            label = paste0("eps1=",eps1),
            size = 3
          ) +
          annotate(
            "text",
            x = phase2_end+14,
            y = eps2,
            label = paste0("eps2=",eps2),
            size = 3
          )
      }
    }
    return(temp_plot)
  }
  
  plots_by_state_path <-
    glue("outputs/{country}/plots_by_state/{state_ac}")
  if (!file.exists(plots_by_state_path))
    dir.create(plots_by_state_path)
  
  ### ploting begin
  
  ## all variables in one plot
  temp_plot <- SEIRD_pred %>%
    pivot_longer(
      cols = c("S", "E", "I1", "I2", "I3", "R", "D"),
      names_to = "variables",
      values_to = "values"
    ) %>%
    select(date, variables, values) %>%
    filter(values >= 1) %>%
    ggplot() +
    geom_line(aes(
      x = date,
      y = log10(values),
      color = variables
    )) +
    labs(
      title = paste0("SEIRD for ", state_ac),
      subtitle = paste0("number of phases: ", number_of_phase)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  
  ggsave(glue("{country}_{state_ac}_SEIRD_variables.png"),
         plot = temp_plot,
         path = plots_by_state_path)

  
  ## plot of cumulative, prediction Vs observed
  
  # cumulative I1,  prediction*test_fraction Vs observed
  temp_plot <- ggplot() +
    geom_line(aes(y = SEIRD_pred$cumulative_I1*test_fraction, x = SEIRD_pred$date),
              color = "red") +
    geom_point(aes(y = target_obs$cases, x = target_obs$date), color = "blue") +
    labs(
      x = "Date",
      y = "cumulative_I1",
      title = paste0(state_ac," cumulative I1,  prediction*test_fraction Vs observed"),
      subtitle = paste0("number of phases=", number_of_phase,"      test_fraction=",test_fraction)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_cumulative_I1.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # cumulative I1, observed data follow by future prediction
  temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
  temp_plot <- ggplot() +
    geom_line(aes(y = temp_pred$cumulative_I1*test_fraction, x = temp_pred$date),
              color = "red") +
    geom_point(aes(y = target_obs$cases, x = target_obs$date), color = "blue") +
    labs(
      x = "Date",
      y = "cumulative_I1",
      title = paste0(state_ac," cumulative I1,  prediction*test_fraction Vs observed"),
      subtitle = paste0("number of phases=", number_of_phase,"   test_fraction=",test_fraction)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot,skip=TRUE)
  ggsave(glue("{country}_{state_ac}_cumulative_I1_filtered.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # cumulative I2+I3 prediction Vs observed
  if (obs_data_kit$hosp_flag == "cumulative")
  {
    temp_plot <- ggplot() +
      geom_line(aes(y = SEIRD_pred$cumulative_I2_I3*hosp_fraction, x = SEIRD_pred$date),
                color = "red") +
      geom_point(aes(y = target_obs$cumulative_hospitalized, x = target_obs$date), color = "blue") +
      labs(
        x = "Date",
        y = "cumulative_I2_plus_I3",
        title = paste0(
          state_ac,
          " cumulative_I2_plus_I3,  prediction*hosp_fraction Vs observed"
        ),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   hosp_fraction=",
          hosp_fraction
        )
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(glue("{country}_{state_ac}_cumulative_I2_plus_I3.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  }
  # X cumulative I2+I3, observed data follow by future prediction
  
  # cumulative D prediction Vs observed
  temp_plot <- ggplot() +
    geom_line(aes(y = SEIRD_pred$D,
                  x = SEIRD_pred$date),
              color = "red") +
    geom_point(aes(y = target_obs$deaths, x = target_obs$date),
               color = "blue") +
    labs(
      x = "Date",
      y = "cumulative_D",
      title = paste0(state_ac,
                     " cumulative_D,  prediction Vs observed"),
      subtitle = paste0("number of phases=",
                        number_of_phase)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_cumulative_D.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # X cumulative D, observed data follow by future prediction
  
  
  
  ## plots of increase, prediction Vs observed
  
  ## I1_increase
  # I1_increase, Predicted*test_fraction VS observed
  temp_plot <-
    ggplot() +
    geom_line(aes(
      y = SEIRD_pred$I1_increase[-1] * test_fraction,
      x = SEIRD_pred$date[-1]
    ),
    color = "red") +
    geom_point(aes(y = obs_data_kit$I1_obs, x = reference_date + obs_data_kit$I1_obsdays),
               color = "blue") +
    labs(
      x = "Date",
      y = "I1_increase",
      title = paste0(state_ac," I1_increase, Predicted*test_fraction VS observed"),
      subtitle = paste0("number of phases=", number_of_phase,"   test_fraction=",test_fraction)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_I1_increase.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # I1_increase, zoomed version
  temp_plot <- temp_plot +
    coord_cartesian(xlim = c(
      max(
        parse_date("2020-02-01"),
        reference_date + min(obs_data_kit$I1_obsdays) - 30
      ),
      reference_date + max(obs_data_kit$I1_obsdays) + 30
    ),
    ylim = c(0, max(obs_data_kit$I1_obs) * 1.1))
   
  ggsave(glue("{country}_{state_ac}_I1_increase_zoomed.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # I1_increase, observed data follow by future prediction
  temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
  temp_plot <-
    ggplot() +
    geom_line(aes(y = temp_pred$I1_increase * test_fraction,
                  x = temp_pred$date),
              color = "red") +
    geom_point(aes(y = obs_data_kit$I1_obs, x = reference_date + obs_data_kit$I1_obsdays),
               color = "blue") +
    labs(
      x = "Date",
      y = "I1_increase",
      title = paste0(state_ac, " I1_increase, Predicted*test_fraction VS observed"),
      subtitle = paste0(
        "number of phases=",
        number_of_phase,
        "   test_fraction=",
        test_fraction
      )
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_I1_increase_ofbp.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  ## I2+I3 increase (hosp) 
  if(obs_data_kit$hosp_flag=="cumulative")
  {
  # I2+I3_increase, Predicted*test_fraction VS observed
  temp_plot <-
    ggplot() +
    geom_line(aes(
      y = SEIRD_pred$hosp_increase[-1] * hosp_fraction,
      x = SEIRD_pred$date[-1]
    ),
    color = "red") +
    geom_point(aes(y = obs_data_kit$hosp_obs, x = reference_date + obs_data_kit$hosp_obsdays),
               color = "blue") +
    labs(
      x = "Date",
      y = "I2_plus_I3_increase",
      title = paste0(state_ac," I2_plus_I3_increase, Predicted*hosp_fraction VS observed"),
      subtitle = paste0("number of phases=", number_of_phase,"   hosp_fraction=",hosp_fraction)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_I2_plus_I3_increase.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # I2+I3_increase, zoomed version
  temp_plot <- temp_plot +
    coord_cartesian(xlim = c(
      max(
        parse_date("2020-02-01"),
        reference_date + min(obs_data_kit$hosp_obsdays) - 30
      ),
      reference_date + max(obs_data_kit$hosp_obsdays) + 30
    ),
    ylim = c(0, max(obs_data_kit$hosp_obs) * 1.1))
  
  ggsave(glue("{country}_{state_ac}_I2_plus_I3_increase_zoomed.png"),
       plot = temp_plot,
       path = plots_by_state_path)  
  
  # I2+I3_increase, observed data follow by future prediction
  temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
  temp_plot <-
    ggplot() +
    geom_line(aes(y = temp_pred$hosp_increase * hosp_fraction,
                  x = temp_pred$date),
              color = "red") +
    geom_point(aes(y = obs_data_kit$hosp_obs, x = reference_date + obs_data_kit$hosp_obsdays),
               color = "blue") +
    labs(
      x = "Date",
      y = "I2_plus_I3_increase",
      title = paste0(state_ac, " I2_plus_I3_increase, Predicted*hosp_fraction VS observed"),
      subtitle = paste0(
        "number of phases=",
        number_of_phase,
        "   hosp_fraction=",
        hosp_fraction
      )
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_I2_plus_I3_increase_ofbp.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  }
  
  ## D_increase
  # D_increase, Predicted VS observed
  temp_plot <-
    ggplot() +
    geom_line(aes(
      y = SEIRD_pred$D_increase[-1],
      x = SEIRD_pred$date[-1]
    ),
    color = "red") +
    geom_point(aes(y = obs_data_kit$D_obs, x = reference_date + obs_data_kit$D_obsdays),
               color = "blue") +
    labs(
      x = "Date",
      y = "D_increase",
      title = paste0(state_ac," D_increase, Predicted VS observed"),
      subtitle = paste0("number of phases=", number_of_phase)
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_D_increase.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  # D_increase, zoomed version
  temp_plot <- temp_plot +
    coord_cartesian(xlim = c(
      max(
        parse_date("2020-02-01"),
        reference_date + min(obs_data_kit$D_obsdays) - 30
      ),
      reference_date + max(obs_data_kit$D_obsdays) + 30
    ),
    ylim = c(0, max(obs_data_kit$D_obs) * 1.1))
   
  ggsave(glue("{country}_{state_ac}_D_increase_zoomed.png"),
       plot = temp_plot,
       path = plots_by_state_path) 
  
  # D_increase, observed data follow by future prediction
  temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
  temp_plot <-
    ggplot() +
    geom_line(aes(y = temp_pred$D_increase,
                  x = temp_pred$date),
              color = "red") +
    geom_point(aes(y = obs_data_kit$D_obs, x = reference_date + obs_data_kit$D_obsdays),
               color = "blue") +
    labs(
      x = "Date",
      y = "D_increase",
      title = paste0(state_ac, " D_increase, Predicted VS observed"),
      subtitle = paste0(
        "number of phases=",
        number_of_phase
      )
    )
  
  temp_plot <- Add_timestamp_vline(temp_plot)
  ggsave(glue("{country}_{state_ac}_D_increase_ofbp.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  ## the current value of all variables, ploted one by one
  for (v_name in c("S", "E", "I1", "I2", "I3", "R", "D"))
  {
    temp_plot <- ggplot(SEIRD_pred) +
      geom_line(aes(x = date, y = SEIRD_pred[[v_name]]), color = "red") +
      labs(
        x = "Date",
        y = paste0(v_name, "_current"),
        title = paste0(state_ac, "Current value of ", v_name),
        subtitle = paste0("number of phases=", number_of_phase)
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(glue("{country}_{state_ac}_{v_name}_current.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  }
  
  ## the current value of I2+I3, prediction*hosp_fraction Vs observed
  ## for those state that used current_hospitalization instead of cumulative
  if(obs_data_kit$hosp_flag=="current")
  {
    temp_plot <- ggplot() +
      geom_line(aes(
        x = SEIRD_pred$date,
        y = (SEIRD_pred$I2 + SEIRD_pred$I3) * hosp_fraction
      ), color = "red") +
      geom_point(
        aes(
          x = reference_date + obs_data_kit$hosp_obsdays,
          y = obs_data_kit$hosp_obs
        ),
        color = "blue"
      ) +
      labs(
        x = "Date",
        y = "I2_plus_I3_current",
        title = paste0(
          state_ac,
          ", Current value of I2+I3, prediction*hosp_fraction Vs obsevered"
        ),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   hosp_fraction=",
          hosp_fraction
        )
      )
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(glue("{country}_{state_ac}_I2_plus_I3_current.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  }
  
  ## the plot of beta1t
  ## to see the data-driven parameters
  temp_plot <- ggplot() +
    geom_line(aes(x = SEIRD_pred$date, y = build_beta1t(dd_para[-(1:3)], s_para$delta)), color =
                "red") +
    labs(
      x = "Date",
      y = "beta1t",
      title = paste0(state_ac,
                     ", beta1t the step function"),
      subtitle = paste0("number of phases=",
                        number_of_phase,
                        "   R0=",
                        dd_para[4],
                        "   delta=",
                        s_para$delta,
                        "   optim_code=",
                        opt_res$convergence),
      caption = paste0(
        "test_fraction=",
        test_fraction,
        "   hosp_fraction=",
        hosp_fraction
      )
    )
  temp_plot <- Add_timestamp_vline(temp_plot,for_beta1t=TRUE)
  ggsave(glue("{country}_{state_ac}_beta1t_and_dd_para.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  ## create a folder that copy all the plots for the specipied state
  ## so you can inspect the result for specific state more easily
  # {
  #   {
  #     plots_by_state_path <- paste0("outputs/plots_by_state/", state_ac)
  #     if (!file.exists(plots_by_state_path))
  #       dir.create(plots_by_state_path)
  #     #file.copy(from = , to = plots_by_state_path, overwrite = TRUE)
  #     ## all variables in one plot
  #     file.copy(
  #       from = paste0(
  #         "outputs/plots/all_variables/",
  #         state_ac,
  #         "_SEIRD_variables.png"
  #       ),
  #       to = plots_by_state_path,
  #       overwrite = TRUE
  #     )
  #     
  #     # cumulative I1, prediction Vs observed
  #     file.copy(
  #       from = paste0(
  #         "outputs/plots/cumulative_I1/obs_and_pred/",
  #         state_ac,
  #         "_cumulative_I1.png"
  #       ),
  #       to = plots_by_state_path,
  #       overwrite = TRUE
  #     )
  #     
  #     # cumulative I1, observed data follow by future prediction
  #     file.copy(
  #       from = paste0(
  #         "outputs/plots/cumulative_I1/obs_follow_by_pred/",
  #         state_ac,
  #         "_cumulative_I1_filtered.png"
  #       ),
  #       to = plots_by_state_path,
  #       overwrite = TRUE
  #     )
  #     
  #     # cumulative I2+I3 prediction Vs observed
  #     if (obs_data_kit$hosp_flag == "cumulative")
  #     {
  #       file.copy(
  #         from = paste0(
  #           "outputs/plots/cumulative_I2_plus_I3/obs_and_pred/",
  #           state_ac,
  #           "_cumulative_I2_plus_I3.png"
  #         ),
  #         to = plots_by_state_path,
  #         overwrite = TRUE
  #       )
  #     }
  # 
  #     # cumulative D prediction Vs observed
  #     file.copy(
  #       from = paste0(
  #         "outputs/plots/cumulative_D/obs_and_pred/",
  #         state_ac,
  #         "_cumulative_D.png"
  #       ),
  #       to = plots_by_state_path,
  #       overwrite = TRUE
  #     )
  #     
  #     for (v_name in c("I1", "I2_plus_I3", "D"))
  #     {
  #       # prediction*test_fraction VS observed
  #       file.copy(
  #         from = paste0(
  #           "outputs/plots/",
  #           v_name,
  #           "_increase/obs_and_pred/",
  #           state_ac,
  #           "_",
  #           v_name,
  #           "_increase.png"
  #         ),
  #         to = plots_by_state_path,
  #         overwrite = TRUE
  #       )
  #       
  #       # zoomed version
  #       file.copy(
  #         from = paste0(
  #           "outputs/plots/",
  #           v_name,
  #           "_increase/obs_follow_by_pred/",
  #           state_ac,
  #           "_",
  #           v_name,
  #           "_increase_zoomed.png"
  #         ),
  #         to = plots_by_state_path,
  #         overwrite = TRUE
  #       )
  #       
  #       # observed data follow by future prediction
  #       file.copy(
  #         from = paste0(
  #           "outputs/plots/",
  #           v_name,
  #           "_increase/obs_follow_by_pred/",
  #           state_ac,
  #           "_",
  #           v_name,
  #           "_increase_ofbp.png"
  #         ),
  #         to = plots_by_state_path,
  #         overwrite = TRUE
  #       )
  #     }
  #     
  #     for (v_name in c("S", "E", "I1", "I2", "I3", "R", "D"))
  #     {
  #       file.copy(
  #         from = paste0(
  #           "outputs/plots/all_variables_one_by_one/",
  #           v_name,
  #           "_current/",
  #           state_ac,
  #           "_",
  #           v_name,
  #           "_current.png"
  #         ),
  #         to = plots_by_state_path,
  #         overwrite = TRUE
  #       )
  #     }
  #     
  #     if (obs_data_kit$hosp_flag == "current")
  #     {
  #       file.copy(
  #         from = paste0(
  #           "outputs/plots/current_I2_plus_I3/",
  #           state_ac,
  #           "_I2_plus_I3_current.png"
  #         ),
  #         to = plots_by_state_path,
  #         overwrite = TRUE
  #       )
  #     }
  #     
  #     ## the plot of beta1t
  #     file.copy(
  #       from = paste0("outputs/plots/beta1t/", state_ac, "_beta1t_and_dd_para.png"),
  #       to = plots_by_state_path,
  #       overwrite = TRUE
  #     )
  #   }
  # }
}
### the code below is for debug
## replot
# make_plots(state_ac = state)
```


## the main script
```{r}
#### setup
### PENDING: explain the parameters

## target setup
country <- "CA"  # "US" or "CA"
# select state or run for all state
# available state list for CA:
# c("AB","BC","CA","MB","NB","NL","NS","ON","QC","SK")
# available state list for US:
# TBD
state <- c("CA")
# Please don't set "all_states" as TRUE, it will takes several hours to finish with a three-phases setup. 
all_states <- FALSE

## basic setup
# state_info <- get_state_info()
state_info <- read_csv(glue("inputs/{country}_state_info.csv"))
reference_date <- parse_date("2020-01-01")
# reference_date is needed in optimizing the t0, the beginning date of the pandemic
days_between_phases <- 14
# days between different time phase, for smoothing
total_days <- 365
# the total length of the SEIRD timeseries, include the past and the future
last_date_with_available_data <- Sys.Date()
# set this to a past date to get a "past prediction"


## for sampling parameter
n_sample <- 5000

## for data-driven parameter
number_of_phase <- 3
# the initial value of data-driven parameters
# error is not used
initial_dd_parameter <- c(
  # log10_I_initial = 1,
  # limit_log10_I_initial=[0.333, 2],
  # error_log10_I_initial=0.33,
  test_fraction = 0.1,
  # limit_test_fraction=[0.02, 1],
  # error_test_fraction=0.02,
  hosp_fraction = 0.7,
  # limit_hosp_fraction=[0.25, 1],
  # error_hosp_fraction=0.05,
  
  t0 = 60,
  # limit_t0=[10, 80],
  # error_t0=2.0,
  R0 = 3.4,
  # limit_R0=[2, 4.5],
  # error_R0=0.05,
  
  phase1_duration = 20,
  # limit_phase1_duration=[5, 40],
  # error_phase1_duration=1,
  eps1 = 0.3,
  # limit_eps1=[0.20, 1.2],
  # error_eps1=0.005,
  
  phase2_duration = 30,
  # supposed to be number of days between second and third ramps
  # limit_phase2_duration=[14, 100],
  # error_t_delta_phases=1,
  eps2 = 0.3
  # limit_eps2=[0.20, 2.0],
  # error_eps2=0.005,
  
  # What's this?
  # errordef=0.5,
)
# upper/lower bound, needed in optimization
dd_parameter_upper <- c(1,1,80,4.5,40,1.2,100,2)
dd_parameter_lower <- c(0.02,0.25,10,2,5,0.2,14,0.1)

print(system.time(rpyseir()))

### the code below is for debug
## replot
# make_plots(state_ac = state)
beep(sound = 1, expr = NULL)
```




