---
title: "rpyseir prototype"
author: "QingXuan Kong"
date: "2020/8/27"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Reminders(20200920):
1.To run the program, first run "## the functions" chunk to load the functions, then run "## the main script".

2.To change the parameters, you could change the corresponding <- assign in "## the main script".

3.To change or add the state, change the state <- c("IL") assign in "## the main script"

4.the SEIRD variables output is in outputs/SEIRD_data/.

5.If you are looking for plots for a specific state, go to "outputs/plots_by_state". If you are looking for plots for a specific type, go to "outputs/plots".

6.The observed dataset is in the input folder. Their are downloaded on 20200919.

"US_timeseries.csv" is from https://github.com/covid-projections/covid-data-model/blob/master/data/timeseries.csv . 

"CA_timeseries.csv" is from https://resources-covid19canada.hub.arcgis.com/datasets/provincial-daily-totals. 

To update them, download the corresponding csv file, rename it and place it in the input folder .

7.I have add a "force correction" for negative increase, so you don't need to fix it in the observed dataset. Any negative increase value will be set as its previous value.
 
8.the result of one-phases setup is bad, might have something to do with the intial value or the limitations of the data-driven parameters.


## the functions
```{r}
library(tidyverse)
library(deSolve)
library(glue)
library(patchwork)
library(beepr)

#### rpyseir
rpyseir <- function()
{
  
  ## check for observed dataset update
  check_for_update_1m3f()
  
  for (state_ac in state) 
  {
    
    # create dir for rds files
    rds_folder <- glue("outputs/{country}/temp_rds/{state_ac}")
    if (!dir.exists(rds_folder)) {
      dir.create(rds_folder)
    }
    
    sampling_para <- get_sampling_parameters(state_ac, n_sample)
    observed_data_kit <-
      parse_observed_data_for_score_calculation(state_ac,rds_folder)
    
    
    ## The overwrite process
    if (overwrite_initial_dd_parameter == T) {
      initial_list<- get_initial_values(state_ac)
    }
    ## end of the overwrite process
    
    
    ## the optimizer
    ### notice: Minimization function is different. nlm doesn't take limits, try optim?
    print(glue("optim for {state_ac} begin, {which(state==state_ac)}/{length(state)}"))
    t_begin <- Sys.time()
    print(t_begin)
    opt_res <-
      optim(
        par = initial_list$initial_dd_parameter,
        fn = score_function,
        gr = NULL,
        s_para = sampling_para,
        obs_data_kit = observed_data_kit,
        method = "L-BFGS-B", #"L-BFGS-B" #"Nelder-Mead"
        lower = initial_list$dd_parameter_lower,
        upper = initial_list$dd_parameter_upper
      )
    
    t_end <- Sys.time()
    
    ## time and optim result prompts
    {
      
      if (opt_res$convergence == 0)
      {
        print(glue("optim for {state_ac} is successful"))
        print(glue("after {opt_res$counts[1]} calls to the score function"))
      }
      else if (opt_res$convergence == 1)
      {
        print(glue("optim for {state_ac} is stopped"))
        print(glue("after {opt_res$counts[1]} calls to the score function"))
        print(glue("message from optim: {opt_res$message}"))
        print(
          "The optim result should be reasonable. Change the initial value or increase the iteration limit might improve the optim result."
        )
      }
      else
      {
        print(glue(
          "optim for {state_ac} encounter error, error code: {opt_res$convergence}"
        ))
        print(glue("after {opt_res$counts[1]} calls to the score function"))
        print(glue("message from optim: {opt_res$message}"))
      }
      print(t_end)
      print(t_end - t_begin)
    }

    ## final run 
    {
      ## get the timeseries
      final_list <-
        final_result_generation(
          state_ac,
          dd_para = opt_res$par,
          s_para = sampling_para,
          obs_data_kit = observed_data_kit
        )
    }
    
    
    ## saving
    {
      ## general saving
      {
        saveRDS(opt_res,
                file = glue(
                  "{rds_folder}/{country}_{state_ac}_opt_res.rds"
                ))
        saveRDS(
          sampling_para,
          file = glue(
            "{rds_folder}/{country}_{state_ac}_sampling_para.rds"
          )
        )
        saveRDS(
          observed_data_kit,
          file = glue(
            "{rds_folder}/{country}_{state_ac}_observed_data_kit.rds"
          )
        )
        write_csv(
          final_list$SEIRD_pred_final,
          path = glue(
            "outputs/{country}/SEIRD_data/{country}_{state_ac}_SEIRD_pred.csv"
          )
        )
        saveRDS(
          final_list,
          file = glue(
            "{rds_folder}/{country}_{state_ac}_final_list.rds"
          )
        )
      }

      ## if better then save to best_record.csv
      {
        suppressMessages(previous_best_record <-
                           read_csv(glue(
                               "inputs/initial_value_and_best_record/{country}_best_record.csv"
                             )))
        target_best_record <-
          previous_best_record %>% filter(alpha_code == state_ac)
        target_best_score <-
          target_best_record$case_and_hosp_score
        
        ## score:report
        {
          print(
            glue(
              "final_score:{final_list$case_and_hosp_score}   previous_best:{target_best_score}"
            )
          )
          print(
            glue(
              "final_D_score:{final_list$death_score}   previous_best:{target_best_record$death_score}"
            )
          )
        }

        
        ## replace if better
        {
          need_replace <- F
          if (target_best_score > final_list$case_and_hosp_score) {
            print(glue("found a better solution. Updating best result record"))
            need_replace <- T
            
            target_best_record <- within(target_best_record, {
              test_fraction <- opt_res$par[1]
              hosp_fraction <- opt_res$par[2]
              t0_date <- opt_res$par[3] + reference_date
              R0 <- opt_res$par[4]
              p1_to_p2_date <- opt_res$par[5] + reference_date
              eps2 <- opt_res$par[6]
              p2_to_p3_date <- opt_res$par[7] + reference_date
              eps3 <- opt_res$par[8]
              p3_to_p4_date <- opt_res$par[9] + reference_date
              eps4 <- opt_res$par[10]
              beta_1 <- R0 * sampling_para$delta * 1
              beta_2 <- R0 * sampling_para$delta * eps2
              beta_3 <- R0 * sampling_para$delta * eps3
              beta_4 <- R0 * sampling_para$delta * eps4
              case_and_hosp_score <- final_list$case_and_hosp_score
              death_score <- final_list$death_score
              time <- t_end
            })
            
            previous_best_record[previous_best_record$alpha_code == state_ac,] <-
              target_best_record
            
            write_csv(
              previous_best_record,
              glue(
                "inputs/initial_value_and_best_record/{country}_best_record.csv"
              )
            )
            # target_best_record$test_fraction <- opt_res$par[1]
            # target_best_record$hosp_fraction <- opt_res$par[2]
            # target_best_record$t0_date <-
            #   opt_res$par[3] + reference_date
            # target_best_record$R0 <- opt_res$par[4]
            # target_best_record$p1_to_p2_date <-
            #   opt_res$par[5] + reference_date
            # target_best_record$eps2 <- opt_res$par[6]
            # target_best_record$p2_to_p3_date <-
            #   opt_res$par[7] + reference_date
            # target_best_record$eps3 <- opt_res$par[8]
            # target_best_record$p3_to_p4_date <-
            #   opt_res$par[9] + reference_date
            # target_best_record$eps4 <- opt_res$par[10]
            # taeget_best_record$beta_1 <- 
            # target_best_record$case_and_hosp_score <- final_list$case_and_hosp_score
            # target_best_record$death_score <- final_list$death_score
            # target_best_record$time <- t_end
            # 
            # previous_best_record[previous_best_record$alpha_code == state_ac, ] <-
            #   target_best_record
            # 
            # write_csv(previous_best_record,
            #           glue("inputs/initial_value_and_best_record/{country}_best_record.csv"))
          }
          else {
            print("Score is not improved.")
          }
        }
 
      }
    }

    
    ### notice: the make_plots function is "separate" from the rest of rpyseir,since it use the rds file as input instead of the parameter input
    make_plots(state_ac,t_end,rds_folder)
    
    ### copy all the result to the cache folder if it is better
    if(need_replace==T){
      ## plots
      sftb_plot_folder <- glue("so_far_the_best/{country}/plots_by_state/{state_ac}")
      if(!dir.exists(sftb_plot_folder)){
        dir.create(sftb_plot_folder)
      }
      plot_file_list <- list.files(glue("outputs/{country}/plots_by_state/{state_ac}/"),full.names = T)
      for (plot_file in plot_file_list) {
        file.copy(
          from = plot_file,
          to = sftb_plot_folder,
          overwrite = T
        )
      }
      
      ## SEIRD_pred
      file.copy(
        from = glue("outputs/{country}/SEIRD_data/{country}_{state_ac}_SEIRD_pred.csv"),
        to = glue("so_far_the_best/{country}/SEIRD_data/"),
        overwrite = T
      )
      
      ## rds
      sftb_rds_folder <-
        glue("so_far_the_best/{country}/temp_rds/{state_ac}")
      if (!dir.exists(sftb_rds_folder)) {
        dir.create(sftb_rds_folder)
      }
      rds_file_list <-
        list.files(glue("outputs/{country}/temp_rds/{state_ac}/"),full.names = T)
      for (rds_file in rds_file_list) {
        file.copy(from = rds_file,
                  to = sftb_rds_folder,
                  overwrite = T)
      }
    }
    
    print("**************")
    
  }
  
}


## generated the sampling parameters
get_sampling_parameters <- function(state_ac, n_sample = 5000)
{
  # most of the comments in this function are from the origin pysier, except for those start with "### notice"
  # I keep them because some of them seems to explain how covid-act-now team get the parameters/distributions.
  # Though I didn't dig into them.
  
  rnorm_min0 <- function(mu, sd)
  {
    return(abs(rnorm(n_sample, mu, sd)))
  }
  
  # this is used to calculate another parameter
  hospitalization_rate_general = rnorm_min0(mu = 0.02, sd = 0.01)
  
  target_info <- state_info %>%
    filter(alpha_code == state_ac)
  
  para_list <- list(
    # basis information
    population = target_info$population,
    state_name = target_info$Name, 
    ## intial value setup move to get_initial_values()
    # p1_to_p2_date = target_info$p1_to_p2_date,
    # p2_to_p3_date = target_info$p2_to_p3_date,
    # p3_to_p4_date = target_info$p3_to_p4_date,
    ### pin_date updatec 20201130
    # lockdown_date = state_info$lock_down_date[which(state_info$alpha_code == state_ac)],
    # reopen_date = state_info$reopen_date[which(state_info$alpha_code == state_ac)],
    
    
    ### notice: the SEIRD initial value setup is moved to get_SEIRD_timeseries()
    
    R0_hospital = mean(runif(n_sample, min = 3.2 / 6, max = 4 / 6)),
    
    # For now we have disabled this bucket and lowered rates of other
    # boxes accordingly. Since we were not modeling different contact
    # rates, this has the same result
    
    ### notice: asymptomatic is not implemented. Comment out corresponding parameters.
    # fraction_asymptomatic = 0
    
    # These parameters produce an IFR ~0.0065 if we had infinite
    # capacity, and about ~0.0125 with capacity constraints imposed
    
    hospitalization_rate_general = mean(hospitalization_rate_general),
    hospitalization_rate_icu = mean(rnorm_min0(mu = 0.30, sd = 0.05) * hospitalization_rate_general),
    
    ### notice: ventilator gourp is merged with I3. Comment out corresponding parameters.
    fraction_icu_requiring_ventilator = mean(rnorm_min0(mu = 0.6, sd = 0.1)),
    sigma = mean(1 / rnorm_min0(mu = 3.0, sd = 0.86)),
    # Sigma = Imperial college - 2 days since that is expected infectious period.
    delta = mean(1 / rgamma(n_sample, shape = 6.0, scale = 1)),
    # Delta = Kind of based on imperial college + CDC digest.
    delta_hospital = mean(1 / rgamma(n_sample, shape = 8.0, scale = 1)),
    # delta_hospital Kind of based on imperial college + CDC digest.
    
    ### notice: asymptomatic is not implemented. Comment out corresponding parameters.
    # kappa = 1,
    # Contact rate for asympt
    # gamma = (1 - fraction_asymptomatic) is not implemented
    # https://www.cdc.gov/coronavirus/2019-ncov/hcp/clinical-guidance-management-patients.html
    
    symptoms_to_hospital_days = mean(rnorm_min0(mu = 6.0, sd = 1.5)),
    hospitalization_length_of_stay_general = mean(rnorm_min0(mu = 7.0, sd = 1)),
    # hospitalization_length_of_stay_icu_avg=8.6,  # Weighted avg of icu w & w/o
    hospitalization_length_of_stay_icu = mean(rnorm_min0(mu = 8.0, sd = 3)),
    
    ### notice: ventilator gourp is merged with I3. Comment out corresponding parameters.
    hospitalization_length_of_stay_icu_and_ventilator =
      mean(rnorm_min0(mu = 9.0, sd = 3)),
    
    # if you assume the ARDS population is the group that would die
    # w/o ventilation, this would suggest a 20-42% mortality rate
    # among general hospitalized patients w/o access to ventilators:
    # “Among all patients, a range of 3% to 17% developed ARDS
    # compared to a range of 20% to 42% for hospitalized patients
    # and 67% to 85% for patients admitted to the ICU.1,4-6,8,11”
    # 10% Of the population should die at saturation levels. CFR
    # from Italy is 11.9% right now, Spain 8.9%.  System has to
    # produce,
    
    ### notice: the saturation mechanics is not inplemented. Comment out corresponding parameters.
    # mortality_rate_no_general_beds = mean(rnorm_min0(mu = 0.10, sd = 0.01)),
    # mortality_rate_no_ICU_beds = 1.0
    mortality_rate_from_hospital = 0.05,
    mortality_rate_from_ICU = mean(rnorm_min0(mu = 0.5, sd = 0.05))
    ### notice: ventilator gourp is merged with I3. Comment out corresponding parameters.
    # mortality_rate_from_ICUVent = 0.70,
    
    ### notice: the saturation mechanics is not inplemented. Comment out corresponding parameters.
    # beds_general=self.beds * (1 - self.bed_utilization) * 2.07
    # 60% utliization, no scaling...
    # TODO.. Patch this After Issue 132
    # beds_ICU=(1 - self.icu_utilization) * self.icu_beds,
    # No scaling, 75% utilization...
    # hospital_capacity_change_daily_rate=1.05,
    # max_hospital_capacity_factor=2.07,
    # initial_hospital_bed_utilization=0.6,
    # Rubinson L, Vaughn F, Nelson S, et al. Mechanical ventilators
    # in US acute care hospitals. Disaster Med Public Health Prep.
    # 2010;4(3):199-206. http://dx.doi.org/10.1001/dmp.2010.18.
    # 0.7 ventilators per ICU bed on average in US ~80k Assume
    # another 20-40% of 100k old ventilators can be used. = 100-120
    # for 100k ICU beds
    # TODO: Update this if possible by county or state. The ref above has state estimates
    # Staff expertise may be a limiting factor:
    # https://sccm.org/getattachment/About-SCCM/Media-Relations/Final-Covid19-Press-Release.pdf?lang=en-US
    # TODO: Patch after #133
    # ventilators=self.icu_beds * np.random.uniform(low=0.9, high=1.1),
  )
  
  return (para_list)
}


### 20201208 mix_datasource_update
parse_observed_data_for_score_calculation <- function(state_ac,rds_folder)
{
  try(if (!country %in% c("US", "CA")) {
    stop(glue("Program for {country} is not implemented yet."))
  })
  
  obs_data_kit <- list()
  observed_dataset_folder <-
    glue("inputs/observed_timerseries_dataset")
  target_data_rds_path <-
    glue("{rds_folder}/{country}_{state_ac}_target_data.rds")
  
  my_smooth <- function(vec, radius) {
    # radius=1 is equal to a window of 3
    res_vec <-
      (lag(vec, n = radius) + vec + lead(vec, n = radius)) / 3
    return(res_vec)
  }
  
  ## import the all observed data
  {
    ## save the datasets, for plots of cumulative
    target_timeseries_list <- list()
    
    if ("can_US" %in% c(case_datasource, hosp_datasource, death_datasource)) {
      suppressMessages(can_US_raw_timeseries <-
                         read_csv(
                           glue(
                             "{observed_dataset_folder}/can_US_dataset/US_timeseries.csv"
                           ),
                           col_types = "cDcccciiiiiiiiiiiiii"
                         ))
      can_US_target_timeseries <- can_US_raw_timeseries %>%
        filter(
          aggregate_level == "state",
          state == state_ac ,
          date < last_date_with_available_data ,
          date > reference_date
        ) %>%
        rename(cumulative_cases = cases, cumulative_deaths = deaths) %>%
        mutate(
          days_to_ref = as.integer(date - reference_date),
          cases_increase = cumulative_cases - lag(cumulative_cases, n = 1),
          deaths_increase = cumulative_deaths - lag(cumulative_deaths, n = 1),
          hospitalized_increase = cumulative_hospitalized - lag(cumulative_hospitalized, n = 1)
        ) %>%
        select(
          state,
          date,
          days_to_ref,
          cumulative_cases,
          cumulative_deaths,
          cumulative_hospitalized,
          current_hospitalized,
          cases_increase,
          deaths_increase,
          hospitalized_increase
        )
      
      rm(can_US_raw_timeseries)  # release memory
      target_timeseries_list$can_US <-
        can_US_target_timeseries # save for cumulative ploting
      
      ## subset again, only take those column used later. Then smooth
      can_US_target_timeseries <- can_US_target_timeseries %>%
        select(
          state,
          days_to_ref,
          cases_increase,
          deaths_increase,
          hospitalized_increase,
          current_hospitalized
        ) %>%
        mutate(across(
          !c(state, days_to_ref),
          ~ my_smooth(vec = .x, radius = window_radius)
        ))
    }
    
    if ("esri_CA" %in% c(case_datasource, hosp_datasource, death_datasource)) {
      suppressMessages(esri_CA_raw_timeseries <-
                         read_csv(
                           glue(
                             "{observed_dataset_folder}/esri_CA_dataset/CA_timeseries.csv"
                           ),
                           col_types = "icciciiiiiiiiiiiii"
                         ))
      
      esri_CA_target_timeseries <- esri_CA_raw_timeseries %>%
        mutate(date = parse_date(str_sub(SummaryDate, end = 10))) %>%
        rename(
          state = Abbreviation,
          cumulative_cases = TotalCases,
          cumulative_deaths = TotalDeaths,
          current_hospitalized = TotalHospitalized
        ) %>%
        filter(state == state_ac ,
               date < last_date_with_available_data ,
               date > reference_date) %>%
        mutate(days_to_ref = as.integer(date - reference_date)) %>%
        rename(cases_increase = DailyTotals, deaths_increase = DailyDeaths) %>%
        select(
          state,
          date,
          days_to_ref,
          cumulative_cases,
          cumulative_deaths,
          current_hospitalized,
          cases_increase,
          deaths_increase,
        )
      
      rm(esri_CA_raw_timeseries)
      target_timeseries_list$esri_CA <- esri_CA_target_timeseries
      
      ## subset again, only take those column used later. Then smooth
      esri_CA_target_timeseries <- esri_CA_target_timeseries %>%
        select(state,
               days_to_ref,
               cases_increase,
               deaths_increase,
               current_hospitalized) %>%
        mutate(across(
          !c(state, days_to_ref),
          ~ my_smooth(vec = .x, radius = window_radius)
        ))
    }
    
    if ("f_1m3f" %in% c(case_datasource, hosp_datasource, death_datasource)) {
      suppressMessages(f_1m3f_raw_timeseries <-
                         read_csv(
                           glue(
                             "{observed_dataset_folder}/f_1m3f_dataset/{country}_timeseries.csv"
                           )
                         ))
      f_1m3f_target_timeseries <-  f_1m3f_raw_timeseries %>%
        filter(
          state_name == state_ac,
          confirmed_date < last_date_with_available_data,
          confirmed_date > reference_date
        ) %>%
        select(confirmed_date,
               state_name,
               county_name,
               confirmed_count,
               death_count) %>%
        group_by(confirmed_date) %>%
        summarise(
          cases_increase = sum(confirmed_count),
          deaths_increase = sum(death_count)
        ) %>%
        mutate(state = state_ac) %>%
        rename(date = confirmed_date) %>%
        arrange(date) %>%
        mutate(
          days_to_ref = as.integer(date - reference_date),
          cumulative_cases = cumsum(cases_increase),
          cumulative_deaths = cumsum(deaths_increase)
        ) %>%
        select(
          state,
          date,
          days_to_ref,
          cumulative_cases,
          cumulative_deaths,
          cases_increase,
          deaths_increase
        )
      
      rm(f_1m3f_raw_timeseries)
      target_timeseries_list$f_1m3f <-
        f_1m3f_target_timeseries # save for cumulative ploting
      
      ## subset again, only take those column used later.
      f_1m3f_target_timeseries <- f_1m3f_target_timeseries %>%
        select(state,
               days_to_ref,
               cases_increase,
               deaths_increase,) %>%
        mutate(across(
          !c(state, days_to_ref),
          ~ my_smooth(vec = .x, radius = window_radius)
        ))
    }
    
    ## save the datasets, for plots of cumulative
    {
      selected_target_timeseries_list <- list()
      selected_target_timeseries_list$case <-
        target_timeseries_list[[case_datasource]]
      selected_target_timeseries_list$hosp <-
        target_timeseries_list[[hosp_datasource]]
      selected_target_timeseries_list$death <-
        target_timeseries_list[[death_datasource]]
      saveRDS(selected_target_timeseries_list,
              file = target_data_rds_path)
    }

  }
  
  ## extract each variables
  {
    ## extract case
    {
      if (case_datasource == "can_US") {
        temp_selected <- can_US_target_timeseries
      }
      else if (case_datasource == "esri_CA") {
        temp_selected <- esri_CA_target_timeseries
      }
      else if (case_datasource == "f_1m3f") {
        temp_selected <- f_1m3f_target_timeseries
      }
      else{
        try(stop(glue("case_datasource = {case_datasource} is invalid.")))
      }
      I1_obsdays <- temp_selected$days_to_ref[!is.na(temp_selected$cases_increase)]
      I1_obs <- temp_selected$cases_increase[!is.na(temp_selected$cases_increase)]
    }
    
    ## extract hosp
    {
      if (hosp_datasource == "can_US") {
        with(can_US_target_timeseries, {
          if (mean(is.na(hospitalized_increase)) < mean(is.na(current_hospitalized)) &
              !any(hospitalized_increase < 0, na.rm = TRUE))
          {
            hosp_flag <<- "cumulative"
            hosp_obsdays <<-
              days_to_ref[!is.na(hospitalized_increase)]
            hosp_obs <<-
              hospitalized_increase[!is.na(hospitalized_increase)]
          }
          else
          {
            hosp_flag <<- "current"
            hosp_obsdays <<-
              days_to_ref[!is.na(current_hospitalized)]
            hosp_obs <<-
              current_hospitalized[!is.na(current_hospitalized)]
          }
        })
      }
      else if (hosp_datasource == "esri_CA") {
        with(esri_CA_target_timeseries, {
          hosp_flag <<- "current"
          hosp_obsdays <<-
            days_to_ref[!is.na(current_hospitalized)]
          hosp_obs <<-
            current_hospitalized[!is.na(current_hospitalized)]
        })
      }
      else if (hosp_datasource == "f_1m3f") {
        try(stop(
          glue(
            "hosp_datasource = {hosp_datasource} is invalid. f_1m3f didn't provide the hosp data."
          )
        ))
      }
      else{
        try(stop(glue("hosp_datasource = {hosp_datasource} is invalid.")))
      }
    }
    
    ## extract death
    {
      if (death_datasource == "can_US") {
        temp_selected <- can_US_target_timeseries
      }
      else if (death_datasource == "esri_CA") {
        temp_selected <- esri_CA_target_timeseries
      }
      else if (death_datasource == "f_1m3f") {
        temp_selected <- f_1m3f_target_timeseries
      }
      else{
        try(stop(glue("death_datasource = {death_datasource} is invalid.")))
      }
      D_obsdays <- temp_selected$days_to_ref[!is.na(temp_selected$deaths_increase)]
      D_obs <- temp_selected$deaths_increase[!is.na(temp_selected$deaths_increase)]
    }
    
  }
  
  ## check whether there are negative "increase"
  {
    if (any(I1_obs < 0))
    {
      print(paste0("negative observed data: I1 of ", state_ac))
      print("replace the negative value with its previous value")
      I1_obs[which(I1_obs < 0)] <-
        I1_obs[which(I1_obs < 0) - 1]
    }
    if (any(D_obs < 0))
    {
      print(paste0("negative observed data: D of ", state_ac))
      print("replace the negative value with its previous value")
      D_obs[which(D_obs < 0)] <- D_obs[which(D_obs < 0) - 1]
    }
    if (any(hosp_obs < 0))
    {
      print(paste0("negative observed data: hosp ", hosp_flag, " of ", state_ac))
      print("replace the negative value with its previous value")
      hosp_obs[which(hosp_obs < 0)] <-
        hosp_obs[which(hosp_obs < 0) - 1]
    }
  }
  
  ## setup the standard deviation
  {
    ## calculate standard deviation
    # chi-square score need standard deviance for each observation
    # don't know why it should be calculation in this way
    # the I1 and hosp std is multiplied by 0.5. This is equal to multiply their chi-square score by 4. It is supposed to "control chi2 mix between hospitalization and deaths"
    # The following comments are the origin comments of std calcualtion from pyseir
    
    # Generate the errors on the observations.
    # Here we throw out a few assumptions to plant a flag...
    # 1. Systematic errors dominate and are likely of order 50% at least based
    # on 100% undercounting of deaths and hospitalizations in many places.
    # Though we account for static undercounting by letting case and hosp
    # counts float, so lets assume the error is a bit smaller for now.
    # 2. 100% is too small for 1 case count or mortality.. We should be much
    #    more confident in large numbers of observations
    # 3. TODO: Deal with this fact.. Actual observations are lower bounds.
    #          Need asymmetric errors.
    # As an error model, absolutes are less important to our problem compared
    # to getting relative error scaling reasonably done. This is not true if
    # drawing contours and confidence intervals which is why we choose large
    # conservative errors to overestimate the uncertainty.
    # As a relative scaling model we think about Poisson processes and scale
    # the errors in the following way:
    # 1. Set the error of the largest observation to 100% of its value.
    # 2. Scale all other errors based on sqrt(value) * sqrt(max_value)
    
    # ## calculate standard deviation
    # I1_std <- sqrt(I1_obs) * sqrt(max(I1_obs)) * 0.5
    # hosp_std <- sqrt(hosp_obs) * sqrt(max(hosp_obs)) * 0.5
    # D_std <- sqrt(D_obs) * sqrt(max(D_obs))
    # # if the observered value is small, increase its standard deviation to make it less influential.
    # I1_std <- ifelse(I1_obs < 5, 3 * I1_std, I1_std)
    # hosp_std <- ifelse(hosp_obs < 5, 3 * hosp_std, hosp_std)
    # D_std <- ifelse(D_obs < 5, 3 * D_std, D_std)
    # # fix 0 standard deviation
    # I1_std <- ifelse(I1_std == 0, 3, I1_std)
    # hosp_std <- ifelse(hosp_std == 0, 3, hosp_std)
    # D_std <- ifelse(D_std == 0, 3, D_std)
    
    ## never mind, just set them as all 1.
    I1_std <- rep(1, length(I1_obs))
    D_std <- rep(1, length(D_obs))
    hosp_std <- rep(1, length(hosp_obs))
  }
  
  ## build the return list and return
  {
    obs_data_kit <- list(
      I1_obsdays = I1_obsdays,
      I1_obs = I1_obs,
      I1_std = I1_std,
      D_obsdays = D_obsdays,
      D_obs = D_obs,
      D_std = D_std,
      hosp_flag = hosp_flag,
      hosp_obsdays = hosp_obsdays,
      hosp_obs = hosp_obs,
      hosp_std = hosp_std
    )
    
    return(obs_data_kit)
  }
}

### 20201212 full_initial_values_update
get_initial_values <- function(state_ac)
{
  ### for reference
  {
  # # the initial value of data-driven parameters
  # ### warning: the initial value and limit of phase_begin will be overwrite as policy date state by state.
  # # error is not used
  # initial_dd_parameter <- c(
  #   # log10_I_initial = 1,
  #   # limit_log10_I_initial=[0.333, 2],
  #   # error_log10_I_initial=0.33,
  #   test_fraction = 0.1,
  #   # limit_test_fraction=[0.02, 1],
  #   # error_test_fraction=0.02,
  #   hosp_fraction = 0.7,
  #   # limit_hosp_fraction=[0.25, 1],
  #   # error_hosp_fraction=0.05,
  #   
  #   t0 = 60,
  #   # limit_t0=[10, 80],
  #   # error_t0=2.0,
  #   R0 = 3.4,
  #   # limit_R0=[2, 4.5],
  #   # error_R0=0.05,
  #   # eps1 = 1
  #   
  #   phase1_duration = 45,
  #   #20
  #   # limit_phase1_duration=[5, 40],
  #   # error_phase1_duration=1,
  #   eps2 = 0.3,
  #   # limit_eps2=[0.20, 1.2],
  #   # error_eps2=0.005,
  #   
  #   phase2_duration = 30,
  #   #30
  #   # supposed to be number of days between second and third ramps
  #   # limit_phase2_duration=[14, 100],
  #   # error_t_delta_phases=1,
  #   eps3 = 0.3,
  #   # limit_eps3=[0.10, 2.0],
  #   # error_eps3=0.005,
  #   
  #   # the fourth phase
  #   phase3_duration = 90,
  #   #60
  #   # limit_phase2_duration=[14, 100],
  #   # error_t_delta_phases=1,
  #   eps4 = 0.5
  #   # limit_eps4=[0.10, 2.0],
  #   # error_eps4=0.005,
  #   
  #   # What's this?
  #   # errordef=0.5,
  # )
   
  }
  

  if (use_best_result == T) {
    path <-
      glue("inputs/initial_value_and_best_record/{country}_best_record.csv")
  } else if (use_best_result == F) {
    path <-
      glue("inputs/initial_value_and_best_record/{country}_initial_values.csv")
  }
  
  ## import
  suppressMessages(
    initial_dd_parameter <-
      read_csv(path) %>%
      filter(alpha_code == state_ac) %>%
      select(test_fraction:eps4) %>%
      mutate(across(
        contains("date"),  ~ as.integer(.x - reference_date)
      )) %>%
      as.numeric()
  )
  
  ## prepare boundary
  dd_parameter_upper <- c(0.5, 1, 75, 4.5, 60, 1.2, 100, 2, 120, 2)
  dd_parameter_lower <- c(0.02, 0.5, 10, 2, 5, 0.2, 14, 0.1, 14, 0.1)
  
  dd_parameter_upper[c(3, 5, 7, 9)] <-
    initial_dd_parameter[c(3, 5, 7, 9)] + opt_radius_of_policydate
  dd_parameter_lower[c(3, 5, 7, 9)] <-
    initial_dd_parameter[c(3, 5, 7, 9)] - opt_radius_of_policydate
  
  return(
    list(
      initial_dd_parameter = initial_dd_parameter,
      dd_parameter_upper = dd_parameter_upper,
      dd_parameter_lower = dd_parameter_lower
    )
  )  
}

## The score function
score_function <- function(dd_para, s_para, obs_data_kit)
{
  ## the before_and_get_pred_part
  {
    param_set <- s_para
    ## parse the input parameter
    param_set$log10_I_initial <- 1
    test_fraction <- dd_para[1]
    hosp_fraction <- dd_para[2]
    t0 <- dd_para[3]
    
    ### 20201103 pin policy update
    if (overwrite_initial_dd_parameter == T)
    {
      supt_para <- dd_to_supt(dd_para)
    }
    else
    {
      supt_para <- dd_para[-(1:3)]
    }
    
    
    ###
    
    # this beta1t is a vector storing the beta1 value on day 1:total_days
    # it represent/determined the number of phases
    param_set$beta1t <- build_beta1t(supt_para, s_para$delta)
    
    SEIRD_pred <- get_SEIRD_timeseries(param_set)
  }


  ## calculate the chi-square score
  {
    score <- 0
    
    with(obs_data_kit, {
      # same procedure for each variable used in score calculation
      if (use_case == T) {
        # calculate increase from cumulative value
        I1_increase <-
          SEIRD_pred$cumulative_I1[-1] - lag(SEIRD_pred$cumulative_I1, n = 1)[-1]
        # get the prediction value where there are observed data available.
        I1_pred <-
          approx(
            x = (1:total_days) + t0,
            y = I1_increase,
            xout = I1_obsdays,
            yleft = 0,
            yright = 0
          )$y * test_fraction
        # calculation the chi-square score
        chi2_I1 <- mean((I1_pred - I1_obs) ^ 2 / I1_std ^ 2)
        score <- score + chi2_I1
      }
      
      if (use_hosp == T) {
        hosp_increase <-
          SEIRD_pred$cumulative_I2_I3[-1] - lag(SEIRD_pred$cumulative_I2_I3, n = 1)[-1]
        
        if (hosp_flag == "cumulative")
        {
          hosp_pred <-
            approx(
              x = (1:total_days) + t0,
              y = hosp_increase,
              xout =  hosp_obsdays,
              yleft = 0,
              yright = 0
            )$y * hosp_fraction
        }
        else if (hosp_flag == "current")
        {
          hosp_pred <-
            approx(
              x = (0:total_days) + t0,
              y = (SEIRD_pred$I2 + SEIRD_pred$I3),
              xout = hosp_obsdays,
              yleft = 0,
              yright = 0
            )$y * hosp_fraction
        }
        chi2_hosp <-
          mean((hosp_pred - hosp_obs) ^ 2 / hosp_std ^ 2)
        score <- score + chi2_hosp
      }
      
      if (use_death == T) {
        D_increase <-
          SEIRD_pred$D[-1] - lag(SEIRD_pred$D, n = 1)[-1]
        
        D_pred <-
          approx(
            x = (1:total_days) + t0,
            y = D_increase,
            xout =  D_obsdays,
            yleft = 0,
            yright = 0
          )$y
        
        chi2_D <- mean((D_pred - D_obs) ^ 2 / D_std ^ 2)
        score <- score + chi2_D
      }
      
      return(score)
    })
  }
}




## Generate the beta1t
build_beta1t <- function(supt_para, delta)
{
  # 1:total_days is the days_from_t0_index
  ### notice: no implementation for eps_future,so no cap on eps3
  if (number_of_phase == 1)
  {
    R0 <- supt_para[1]
    
    beta1t <- R0 * delta * rep(1, (total_days+1))
    return(beta1t)
  }
  else if (number_of_phase == 2)
  {
    R0 <- supt_para[1]
    phase1_duration <- supt_para[2]
    eps2 <- supt_para[3]
    
    beta1t <-
      approx(
        x = c(1,
              phase1_duration,
              phase1_duration + days_between_phases),
        y = R0 * delta * c(1, 1, eps2),
        xout = 1:(total_days+1),
        yleft = R0 * delta * 1,
        yright = R0 * delta * eps2
      )
    return(beta1t$y)
  }
  else if (number_of_phase == 3)
  {
    R0 <- supt_para[1]
    phase1_duration <- supt_para[2]
    eps2 <- supt_para[3]
    phase2_duration <- supt_para[4]
    eps3 <- supt_para[5]
    
    # beta1t <-
    #   approx(
    #     x = c(
    #       1,
    #       phase1_duration,
    #       phase1_duration + days_between_phases,
    #       phase1_duration + days_between_phases + phase2_duration,
    #       phase1_duration + days_between_phases + phase2_duration + days_between_phases
    #     ),
    #     y = R0 * delta * c(1, 1, eps2, eps2, eps3),
    #     xout = 1:(total_days + 1),
    #     yleft = R0 * delta * 1,
    #     yright = R0 * delta * eps3
    #   )
    beta1t <-
      approx(
        x = c(
          1,
          phase1_duration,
          phase1_duration + days_between_phases,
          phase1_duration + phase2_duration,
          phase1_duration + phase2_duration + days_between_phases
        ),
        y = R0 * delta * c(1, 1, eps2, eps2, eps3),
        xout = 1:(total_days + 1),
        yleft = R0 * delta * 1,
        yright = R0 * delta * eps3
      )
    return(beta1t$y)
  }
  else if (number_of_phase == 4)
  {
    R0 <- supt_para[1]
    phase1_duration <- supt_para[2]
    eps2 <- supt_para[3]
    phase2_duration <- supt_para[4]
    eps3 <- supt_para[5]
    phase3_duration <- supt_para[6]
    eps4 <- supt_para[7]
    
    # beta1t <-
    #   approx(
    #     x = c(
    #       1,
    #       phase1_duration,
    #       phase1_duration + days_between_phases,
    #       phase1_duration + days_between_phases + phase2_duration,
    #       phase1_duration + days_between_phases + phase2_duration + days_between_phases,
    #       phase1_duration + days_between_phases + phase2_duration + days_between_phases + phase3_duration,
    #       phase1_duration + days_between_phases + phase2_duration + days_between_phases + phase3_duration + days_between_phases
    #     ),
    #     y = R0 * delta * c(1, 1, eps2, eps2, eps3, eps3, eps4),
    #     xout = 1:(total_days+1),
    #     yleft = R0 * delta * 1,
    #     yright = R0 * delta * eps4
    #   )
    beta1t <-
      approx(
        x = c(
          1,
          phase1_duration,
          phase1_duration + days_between_phases,
          phase1_duration + phase2_duration,
          phase1_duration + phase2_duration + days_between_phases,
          phase1_duration + phase2_duration + phase3_duration,
          phase1_duration + phase2_duration + phase3_duration + days_between_phases
        ),
        y = R0 * delta * c(1, 1, eps2, eps2, eps3, eps3, eps4),
        xout = 1:(total_days+1),
        yleft = R0 * delta * 1,
        yright = R0 * delta * eps4
      )
    return(beta1t$y)
  }
  
  try(if (!number_of_phase %in% c(1,2,3,4)) {
    stop(paste0(number_of_phase, " phases is not implemented yet."))
  })
}




## the SEIRD model
get_SEIRD_timeseries <- function(param_set)
{
  # Load up some number of initial exposed so the initial flow into infected is stable.(origin pyseir comment)
  steady_state_exposed_to_infected_ratio <- 1.2
  I1_initial <- 10 ^ param_set$log10_I_initial
  E_initial <- I1_initial * steady_state_exposed_to_infected_ratio
  S_initial <- param_set$population - I1_initial - E_initial
  
  init_vals <- c(
    S = S_initial,
    E = E_initial,
    I1 = I1_initial,
    I2 = 0,
    I3 = 0,
    R = 0,
    D = 0,
    # these two stores the values that might be needed in the score function
    # we are not part of the SEIRD model, just something calculated from the SEIRD variables.
    cumulative_I1 = I1_initial,
    cumulative_I2_I3 = 0
  )
  
  result <-
    ode(y = init_vals,
        times = 0:total_days,
        func = SEIRD_timestep,
        param_set)
  result <- as.data.frame(result)
  # somehow the init_vals mess up the column name of the result. Fix it.
  names(result)[c(2, 3, 4, 9)] <- c("S", "E", "I1", "cumulative_I1")
  return(result)
}

SEIRD_timestep <- function(t, current_vals, param_set)
{
  S <- current_vals[1]
  E <- current_vals[2]
  I1 <- current_vals[3]
  I2 <- current_vals[4]
  I3 <- current_vals[5]
  R <- current_vals[6]
  D <- current_vals[7]
  
  # these two stores the values that might be needed in the score function
  cumulative_I1 = current_vals[8]
  cumulative_I2_I3 = current_vals[9]
  
  with(param_set, {
    number_exposed <-
      beta1t[t+1] * S / population * I1 + R0_hospital * delta_hospital * S / population *
      (I2 + I3)
    dS <- -number_exposed
    
    exposed_and_symptomatic <- E * sigma
    dE <- number_exposed - exposed_and_symptomatic
    
    ### notice: the saturation mechanics is not inplemented
    infected_and_recovered_without_hospital <- I1 * delta
    infected_and_to_I2 <-
      I1 * (hospitalization_rate_general - hospitalization_rate_icu) / symptoms_to_hospital_days
    infected_and_to_I3 <-
      I1 * hospitalization_rate_icu / symptoms_to_hospital_days
    dI1 <-
      exposed_and_symptomatic - infected_and_recovered_without_hospital - infected_and_to_I2 - infected_and_to_I3
    
    ### notice: the saturation mechanics is not inplemented.
    # basically, the outflow of I2 and I3 is current_val/length_of_stay
    # mortality_rate% of them die, the rest is considered recovered.
    died_from_I2 <-
      I2 * mortality_rate_from_hospital / hospitalization_length_of_stay_general
    died_from_I3 <-
      I3 * mortality_rate_from_ICU / hospitalization_length_of_stay_icu
    recovered_from_I2 <-
      I2 * (1 - mortality_rate_from_hospital) / hospitalization_length_of_stay_general
    recovered_from_I3 <-
      I3 * (1 - mortality_rate_from_ICU) / hospitalization_length_of_stay_icu
    dI2 <- infected_and_to_I2 - died_from_I2 - recovered_from_I2
    dI3 <- infected_and_to_I3 - died_from_I3 - recovered_from_I3
    dR <-
      infected_and_recovered_without_hospital + recovered_from_I2 + recovered_from_I3
    dD <- died_from_I2 + died_from_I3
    
    # these two stores the values that might be needed in the score function
    # only add inflow
    dcumulative_I1 <- exposed_and_symptomatic
    dcumulative_I2_I3 <-
      infected_and_to_I2 + infected_and_to_I3
    
    result <-
      c(dS, dE, dI1, dI2, dI3, dR, dD, dcumulative_I1, dcumulative_I2_I3)
    
    return(list(result))
  })
}




## calculate the final sEIRD data and make the plot
final_result_generation <- function(state_ac,dd_para,s_para,obs_data_kit)
{
  ## the before_and_get_pred_part
  {
    param_set <- s_para
    ## parse the input parameter
    param_set$log10_I_initial <- 1
    test_fraction <- dd_para[1]
    hosp_fraction <- dd_para[2]
    t0 <- dd_para[3]
    
    # this beta1t is a vector storing the beta1 value on day 1:total_days
    # it represent/determined the number of phases
    
    ### 20201103 pin policy update
    if (overwrite_initial_dd_parameter == T)
    {
      supt_para <- dd_to_supt(dd_para)
    }
    else
    {
      supt_para <- dd_para[-(1:3)]
    }
    ###
    
    param_set$beta1t <- build_beta1t(supt_para, s_para$delta)
    
    SEIRD_pred <- get_SEIRD_timeseries(param_set)
  }

  
  ## generating the final SEIRD output
  {
    # calculate the increase
    I1_increase <-
      SEIRD_pred$cumulative_I1[-1] - lag(SEIRD_pred$cumulative_I1, n = 1)[-1]
    hosp_increase <-
      SEIRD_pred$cumulative_I2_I3[-1] - lag(SEIRD_pred$cumulative_I2_I3, n = 1)[-1]
    D_increase <-
      SEIRD_pred$D[-1] - lag(SEIRD_pred$D, n = 1)[-1]
    
    # finialize and save the SEIRD prediction dataset
    SEIRD_pred_final <- SEIRD_pred %>%
      mutate(
        date = reference_date + t0 + time,
        I1_increase = c(0, I1_increase),
        hosp_increase = c(0, hosp_increase),
        D_increase = c(0, D_increase)
      ) %>%
      mutate(
        I1_tested = I1 * test_fraction,
        I1_increase_tested = I1_increase * test_fraction,
        cumulative_I1_tested = cumulative_I1 * test_fraction
      ) %>%
      rename(days_to_t0 = time) %>%
      select(date, days_to_t0, everything())
  }

  ## get the score using the same code from score function. It didn't output death_score so can't use it directly.
  ## calculate the chi-square score
  {
    case_and_hosp_score <- NA
    death_score <- NA
    
    with(obs_data_kit, {
      # same procedure for each variable used in score calculation
      if (use_case == T) {
        # calculate increase from cumulative value
        I1_increase <-
          SEIRD_pred$cumulative_I1[-1] - lag(SEIRD_pred$cumulative_I1, n = 1)[-1]
        # get the prediction value where there are observed data available.
        I1_pred <-
          approx(
            x = (1:total_days) + t0,
            y = I1_increase,
            xout = I1_obsdays,
            yleft = 0,
            yright = 0
          )$y * test_fraction
        # calculation the chi-square score
        chi2_I1 <- mean((I1_pred - I1_obs) ^ 2 / I1_std ^ 2)
        score <- chi2_I1
      }
      
      if (use_hosp == T) {
        hosp_increase <-
          SEIRD_pred$cumulative_I2_I3[-1] - lag(SEIRD_pred$cumulative_I2_I3, n = 1)[-1]
        
        if (hosp_flag == "cumulative")
        {
          hosp_pred <-
            approx(
              x = (1:total_days) + t0,
              y = hosp_increase,
              xout =  hosp_obsdays,
              yleft = 0,
              yright = 0
            )$y * hosp_fraction
        }
        else if (hosp_flag == "current")
        {
          hosp_pred <-
            approx(
              x = (0:total_days) + t0,
              y = (SEIRD_pred$I2 + SEIRD_pred$I3),
              xout = hosp_obsdays,
              yleft = 0,
              yright = 0
            )$y * hosp_fraction
        }
        chi2_hosp <-
          mean((hosp_pred - hosp_obs) ^ 2 / hosp_std ^ 2)
        score <- score + chi2_hosp
      }
      
      
        D_increase <-
          SEIRD_pred$D[-1] - lag(SEIRD_pred$D, n = 1)[-1]
        
        D_pred <-
          approx(
            x = (1:total_days) + t0,
            y = D_increase,
            xout =  D_obsdays,
            yleft = 0,
            yright = 0
          )$y
        
        chi2_D <- mean((D_pred - D_obs) ^ 2 / D_std ^ 2)
      
      
      case_and_hosp_score <<- score
      death_score <<- chi2_D
    })
    
  }
  
  
  return(
    list(
      SEIRD_pred_final = SEIRD_pred_final,
      case_and_hosp_score = case_and_hosp_score,
      death_score = death_score
    )
  )
}

make_plots <- function(state_ac,t_end=Sys.time(),rds_folder)
{
  ### notice: the make_plots function is "separate" from the rest of rpyseir
  ### It use the rds file as input instead of the parameter input
  ### so it could run individually, as long as you have run rpyseir for your chosen state for once and generate the rds files
  ### This will come in handy if you want to change the label of my plot
  ### In that case, you can just tweak make_plot(state_ac) and run it, without running rpyseir() again
  
  ## reload the rds files
  dd_para <-
    readRDS(file = glue("{rds_folder}/{country}_{state_ac}_opt_res.rds"))$par
  opt_res <-
    readRDS(file = glue("{rds_folder}/{country}_{state_ac}_opt_res.rds"))
  s_para <-
    readRDS(file = glue("{rds_folder}/{country}_{state_ac}_sampling_para.rds"))
  obs_data_kit <-
    readRDS(file = glue("{rds_folder}/{country}_{state_ac}_observed_data_kit.rds"))
  suppressMessages(SEIRD_pred <-
                     read_csv(
                       file = glue(
                         "outputs/{country}/SEIRD_data/{country}_{state_ac}_SEIRD_pred.csv"
                       )
                     ))
  target_data <- 
    readRDS(file = glue("{rds_folder}/{country}_{state_ac}_target_data.rds"))
  
  
  test_fraction <- dd_para[1]
  hosp_fraction <- dd_para[2]
  t0 <- dd_para[3]
  ### 20201208 mix datasource update
  # beginning_of_future <- last_date_with_available_data
  beginning_of_future <-
    min(reference_date + max(obs_data_kit$I1_obsdays),
        last_date_with_available_data)
  
  ### 20201103 pin policy update
  if (overwrite_initial_dd_parameter == T)
  {
    supt_para <- dd_to_supt(dd_para)
  }
  else
  {
    supt_para <- dd_para[-(1:3)]
  }
  ###
  
  ## need a function to add the vertical lines bases on the number of phases
  Add_timestamp_vline <-
    function(temp_plot,
             skip = FALSE,
             for_beta1t = FALSE)
    {
      temp_plot <- temp_plot +
        geom_vline(xintercept = reference_date + t0, color = "black") +
        annotate(
          "text",
          x = reference_date + t0,
          y = 0,
          label = "t0",
          size = 3
        ) +
        geom_vline(xintercept = beginning_of_future, color = "black") +
        annotate(
          "text",
          x = beginning_of_future,
          y = 0,
          label = "pred_begin",
          size = 3
        ) +
        labs(caption = t_end)
      
      ## some plots don't need to add the phase stuff, so here is a way to skip them
      if (skip == TRUE)
      {
        return(temp_plot)
      }
      
      ## check number_of_phase and add vertical lines where the phase is changed
      try(if (!number_of_phase %in% c(1, 2, 3, 4)) {
        stop(paste0(number_of_phase, " phases is not implemented yet."))
      })
      
      if (number_of_phase == 2)
      {
        phase1_duration <- supt_para[2]
        eps2 <- supt_para[3]
        phase1_end <- reference_date + t0 + phase1_duration
        temp_plot <- temp_plot +
          geom_vline(xintercept = phase1_end, color = "black") +
          annotate(
            "text",
            x = phase1_end,
            y = 0,
            label = "p1_end",
            size = 3
          )
        if (for_beta1t == TRUE)
        {
          temp_plot <- temp_plot +
            annotate(
              "text",
              x = phase1_end + days_between_phases,
              y = eps2,
              label = paste0("eps2=", eps2),
              size = 3
            )
        }
      }
      else if (number_of_phase == 3)
      {
        phase1_duration <- supt_para[2]
        phase1_end <- reference_date + t0 + phase1_duration
        eps2 <- supt_para[3]
        phase2_duration <- supt_para[4]
        # phase2_end <-
        #   reference_date + t0 + phase1_duration + days_between_phases + phase2_duration
        phase2_end <-
          reference_date + t0 + phase1_duration + phase2_duration
        eps3 <- supt_para[5]
        temp_plot <- temp_plot +
          geom_vline(xintercept = phase1_end, color = "black") +
          annotate(
            "text",
            x = phase1_end,
            y = 0,
            label = "p1_end",
            size = 3
          ) +
          geom_vline(xintercept = phase2_end, color = "black") +
          annotate(
            "text",
            x = phase2_end,
            y = 0,
            label = "p2_end",
            size = 3
          )
        if (for_beta1t == TRUE)
        {
          temp_plot <- temp_plot +
            annotate(
              "text",
              x = phase1_end + days_between_phases,
              y = eps2,
              label = paste0("eps2=", eps2),
              size = 3
            ) +
            annotate(
              "text",
              x = phase2_end + days_between_phases,
              y = eps3,
              label = paste0("eps3=", eps3),
              size = 3
            )
        }
      }
      else if (number_of_phase == 4)
      {
        phase1_duration <- supt_para[2]
        phase1_end <- reference_date + t0 + phase1_duration
        eps2 <- supt_para[3]
        phase2_duration <- supt_para[4]
        # phase2_end <-
        #   reference_date + t0 + phase1_duration + days_between_phases + phase2_duration
        phase2_end <-
          reference_date + t0 + phase1_duration + phase2_duration
        eps3 <- supt_para[5]
        phase3_duration <- supt_para[6]
        # phase3_end <-
        #   reference_date + t0 + phase1_duration + days_between_phases + phase2_duration + days_between_phases + phase3_duration
        phase3_end <-
          reference_date + t0 + phase1_duration + phase2_duration  + phase3_duration
        eps4 <- supt_para[7]
        
        
        temp_plot <- temp_plot +
          geom_vline(xintercept = phase1_end, color = "black") +
          annotate(
            "text",
            x = phase1_end,
            y = 0,
            label = "p1_end",
            size = 3
          ) +
          geom_vline(xintercept = phase2_end, color = "black") +
          annotate(
            "text",
            x = phase2_end,
            y = 0,
            label = "p2_end",
            size = 3
          ) +
          geom_vline(xintercept = phase3_end, color = "black") +
          annotate(
            "text",
            x = phase3_end,
            y = 0,
            label = "p3_end",
            size = 3
          )
        
        if (for_beta1t == TRUE)
        {
          temp_plot <- temp_plot +
            annotate(
              "text",
              x = phase1_end + days_between_phases,
              y = eps2,
              label = paste0("eps2=", eps2),
              size = 3
            ) +
            annotate(
              "text",
              x = phase2_end + days_between_phases,
              y = eps3,
              label = paste0("eps3=", eps3),
              size = 3
            ) +
            annotate(
              "text",
              x = phase3_end + days_between_phases,
              y = eps4,
              label = paste0("eps4=", eps4),
              size = 3
            )
        }
      }
        return(temp_plot)
    }
  
  plots_by_state_path <-
    glue("outputs/{country}/plots_by_state/{state_ac}")
  if (!dir.exists(plots_by_state_path))
    dir.create(plots_by_state_path)
  
  ### ploting begin

  ## plot of cumulative, prediction Vs observed
  {
    # cumulative I1,  prediction*test_fraction Vs observed
    temp_plot <- ggplot() +
      geom_line(aes(y = SEIRD_pred$cumulative_I1 * test_fraction,
                    x = SEIRD_pred$date),
                color = "red") +
      geom_point(aes(y = target_data$case$cumulative_cases,
                     x = target_data$case$date),
                 color = "blue") +
      labs(
        x = "Date",
        y = "cumulative_I1",
        title = paste0(state_ac,
                       " cumulative I1,  prediction*test_fraction Vs observed"),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "      test_fraction=",
          test_fraction
        )
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(glue("{country}_{state_ac}_cumulative_I1.png"),
           plot = temp_plot,
           path = plots_by_state_path)
    
    # cumulative I1, observed data follow by future prediction
    temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
    temp_plot <- ggplot() +
      geom_line(aes(y = temp_pred$cumulative_I1 * test_fraction,
                    x = temp_pred$date),
                color = "red") +
      geom_point(aes(y = target_data$case$cumulative_cases,
                     x = target_data$case$date),
                 color = "blue") +
      labs(
        x = "Date",
        y = "cumulative_I1",
        title = paste0(state_ac,
                       " cumulative I1,  prediction*test_fraction Vs observed"),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   test_fraction=",
          test_fraction
        )
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot, skip = TRUE)
    ggsave(
      glue("{country}_{state_ac}_cumulative_I1_filtered.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
    
    
    # cumulative I2+I3 prediction Vs observed
    if (obs_data_kit$hosp_flag == "cumulative")
    {
      temp_plot <- ggplot() +
        geom_line(aes(
          y = SEIRD_pred$cumulative_I2_I3 * hosp_fraction,
          x = SEIRD_pred$date
        ),
        color = "red") +
        geom_point(
          aes(
            y = target_data$hosp$cumulative_hospitalized,
            x = target_data$hosp$date
          ),
          color = "blue"
        ) +
        labs(
          x = "Date",
          y = "cumulative_I2_plus_I3",
          title = paste0(
            state_ac,
            " cumulative_I2_plus_I3,  prediction*hosp_fraction Vs observed"
          ),
          subtitle = paste0(
            "number of phases=",
            number_of_phase,
            "   hosp_fraction=",
            hosp_fraction
          )
        )
      
      temp_plot <- Add_timestamp_vline(temp_plot)
      ggsave(
        glue("{country}_{state_ac}_cumulative_I2_plus_I3.png"),
        plot = temp_plot,
        path = plots_by_state_path
      )
    }
    # X cumulative I2+I3, observed data follow by future prediction
    
    
    
    # cumulative D prediction Vs observed
    temp_plot <- ggplot() +
      geom_line(aes(y = SEIRD_pred$D,
                    x = SEIRD_pred$date),
                color = "red") +
      geom_point(aes(
        y = target_data$death$cumulative_deaths,
        x = target_data$death$date
      ),
      color = "blue") +
      labs(
        x = "Date",
        y = "cumulative_D",
        title = paste0(state_ac,
                       " cumulative_D,  prediction Vs observed"),
        subtitle = paste0("number of phases=",
                          number_of_phase)
      )
    
     temp_plot <- Add_timestamp_vline(temp_plot)
     ggsave(glue("{country}_{state_ac}_cumulative_D.png"),
           plot = temp_plot,
           path = plots_by_state_path)
    
     # X cumulative D, observed data follow by future prediction
    }

  
  
  ## plots of increase, prediction Vs observed
  {
    ## I1_increase
    # I1_increase, Predicted*test_fraction VS observed
    temp_plot <-
      ggplot() +
      geom_line(aes(y = SEIRD_pred$I1_increase[-1] * test_fraction,
                    x = SEIRD_pred$date[-1]),
                color = "red") +
      geom_point(aes(y = obs_data_kit$I1_obs, x = reference_date + obs_data_kit$I1_obsdays),
                 color = "blue") +
      labs(
        x = "Date",
        y = "I1_increase",
        title = paste0(state_ac, " I1_increase, Predicted*test_fraction VS observed"),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   test_fraction=",
          test_fraction
        )
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(glue("{country}_{state_ac}_I1_increase.png"),
           plot = temp_plot,
           path = plots_by_state_path)
    
    I1_plot <- temp_plot
    
    # I1_increase, zoomed version
    temp_plot <- temp_plot +
      coord_cartesian(xlim = c(
        max(
          parse_date("2020-02-01"),
          reference_date + min(obs_data_kit$I1_obsdays) - 30
        ),
        reference_date + max(obs_data_kit$I1_obsdays) + 30
      ),
      ylim = c(0, max(obs_data_kit$I1_obs) * 1.1))
    
    ggsave(
      glue("{country}_{state_ac}_I1_increase_zoomed.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
    
    # I1_increase, observed data follow by future prediction
    temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
    temp_plot <-
      ggplot() +
      geom_line(aes(y = temp_pred$I1_increase * test_fraction,
                    x = temp_pred$date),
                color = "red") +
      geom_point(aes(y = obs_data_kit$I1_obs, x = reference_date + obs_data_kit$I1_obsdays),
                 color = "blue") +
      labs(
        x = "Date",
        y = "I1_increase",
        title = paste0(state_ac, " I1_increase, Predicted*test_fraction VS observed"),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   test_fraction=",
          test_fraction
        )
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(
      glue("{country}_{state_ac}_I1_increase_ofbp.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
    
    
    ## I2+I3 increase (hosp)
    if (obs_data_kit$hosp_flag == "cumulative")
    {
      # I2+I3_increase, Predicted*test_fraction VS observed
      temp_plot <-
        ggplot() +
        geom_line(aes(
          y = SEIRD_pred$hosp_increase[-1] * hosp_fraction,
          x = SEIRD_pred$date[-1]
        ),
        color = "red") +
        geom_point(
          aes(
            y = obs_data_kit$hosp_obs,
            x = reference_date + obs_data_kit$hosp_obsdays
          ),
          color = "blue"
        ) +
        labs(
          x = "Date",
          y = "I2_plus_I3_increase",
          title = paste0(
            state_ac,
            " I2_plus_I3_increase, Predicted*hosp_fraction VS observed"
          ),
          subtitle = paste0(
            "number of phases=",
            number_of_phase,
            "   hosp_fraction=",
            hosp_fraction
          )
        )
      
      temp_plot <- Add_timestamp_vline(temp_plot)
      ggsave(
        glue("{country}_{state_ac}_I2_plus_I3_increase.png"),
        plot = temp_plot,
        path = plots_by_state_path
      )
      
      hosp_plot <- temp_plot
      
      # I2+I3_increase, zoomed version
      temp_plot <- temp_plot +
        coord_cartesian(xlim = c(
          max(
            parse_date("2020-02-01"),
            reference_date + min(obs_data_kit$hosp_obsdays) - 30
          ),
          reference_date + max(obs_data_kit$hosp_obsdays) + 30
        ),
        ylim = c(0, max(obs_data_kit$hosp_obs) * 1.1))
      
      ggsave(
        glue("{country}_{state_ac}_I2_plus_I3_increase_zoomed.png"),
        plot = temp_plot,
        path = plots_by_state_path
      )
      
      # I2+I3_increase, observed data follow by future prediction
      temp_pred <-
        SEIRD_pred %>% filter(date >= beginning_of_future)
      temp_plot <-
        ggplot() +
        geom_line(aes(
          y = temp_pred$hosp_increase * hosp_fraction,
          x = temp_pred$date
        ),
        color = "red") +
        geom_point(
          aes(
            y = obs_data_kit$hosp_obs,
            x = reference_date + obs_data_kit$hosp_obsdays
          ),
          color = "blue"
        ) +
        labs(
          x = "Date",
          y = "I2_plus_I3_increase",
          title = paste0(
            state_ac,
            " I2_plus_I3_increase, Predicted*hosp_fraction VS observed"
          ),
          subtitle = paste0(
            "number of phases=",
            number_of_phase,
            "   hosp_fraction=",
            hosp_fraction
          )
        )
      
      temp_plot <- Add_timestamp_vline(temp_plot)
      ggsave(
        glue("{country}_{state_ac}_I2_plus_I3_increase_ofbp.png"),
        plot = temp_plot,
        path = plots_by_state_path
      )
    }
    
    
    ## D_increase
    # D_increase, Predicted VS observed
    temp_plot <-
      ggplot() +
      geom_line(aes(y = SEIRD_pred$D_increase[-1],
                    x = SEIRD_pred$date[-1]),
                color = "red") +
      geom_point(aes(y = obs_data_kit$D_obs, x = reference_date + obs_data_kit$D_obsdays),
                 color = "blue") +
      labs(
        x = "Date",
        y = "D_increase",
        title = paste0(state_ac, " D_increase, Predicted VS observed"),
        subtitle = paste0("number of phases=", number_of_phase)
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(glue("{country}_{state_ac}_D_increase.png"),
           plot = temp_plot,
           path = plots_by_state_path)
    
    # D_increase, zoomed version
    temp_plot <- temp_plot +
      coord_cartesian(xlim = c(
        max(
          parse_date("2020-02-01"),
          reference_date + min(obs_data_kit$D_obsdays) - 30
        ),
        reference_date + max(obs_data_kit$D_obsdays) + 30
      ),
      ylim = c(0, max(obs_data_kit$D_obs) * 1.1))
    
    ggsave(
      glue("{country}_{state_ac}_D_increase_zoomed.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
    
    # D_increase, observed data follow by future prediction
    temp_pred <- SEIRD_pred %>% filter(date >= beginning_of_future)
    temp_plot <-
      ggplot() +
      geom_line(aes(y = temp_pred$D_increase,
                    x = temp_pred$date),
                color = "red") +
      geom_point(aes(y = obs_data_kit$D_obs, x = reference_date + obs_data_kit$D_obsdays),
                 color = "blue") +
      labs(
        x = "Date",
        y = "D_increase",
        title = paste0(state_ac, " D_increase, Predicted VS observed"),
        subtitle = paste0("number of phases=",
                          number_of_phase)
      )
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(
      glue("{country}_{state_ac}_D_increase_ofbp.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
  }

  

  
  ## the current value of I2+I3, prediction*hosp_fraction Vs observed
  ## for those state that used current_hospitalization instead of cumulative
  if (obs_data_kit$hosp_flag == "current")
  {
    temp_plot <- ggplot() +
      geom_line(aes(
        x = SEIRD_pred$date,
        y = (SEIRD_pred$I2 + SEIRD_pred$I3) * hosp_fraction
      ), color = "red") +
      geom_point(
        aes(
          x = reference_date + obs_data_kit$hosp_obsdays,
          y = obs_data_kit$hosp_obs
        ),
        color = "blue"
      ) +
      labs(
        x = "Date",
        y = "I2_plus_I3_current",
        title = paste0(
          state_ac,
          ", Current value of I2+I3, prediction*hosp_fraction Vs obsevered"
        ),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   hosp_fraction=",
          hosp_fraction
        )
      )
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(
      glue("{country}_{state_ac}_I2_plus_I3_current.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
    hosp_plot <- temp_plot
  }

  
  
  ## the plot of beta1t
  ## to see the data-driven parameters
  temp_plot <- ggplot() +
    geom_line(aes(x = SEIRD_pred$date, y = build_beta1t(supt_para, s_para$delta)), color ="red") +
    labs(
      x = "Date",
      y = "beta1t",
      title = paste0(state_ac,
                     ", beta1t the step function"),
      subtitle = paste0("number of phases=",
                        number_of_phase,
                        "   R0=",
                        supt_para[1],
                        "   delta=",
                        s_para$delta,
                        "   optim_code=",
                        opt_res$convergence),
      caption = paste0(t_end,
        "test_fraction=",
        test_fraction,
        "   hosp_fraction=",
        hosp_fraction
      )
    )
  temp_plot <- Add_timestamp_vline(temp_plot,for_beta1t=TRUE)
  ggsave(glue("{country}_{state_ac}_beta1t_and_dd_para.png"),
       plot = temp_plot,
       path = plots_by_state_path)
  
  ## compareing rseir and pyseir
  # for US only
  if (country == "US")
  {
    pyseir_res <-
      readRDS("inputs/pyseir_output/pyseir_res_20201111.rds") %>%
      filter(State == state_info$Name[state_info$alpha_code == state_ac])
    
    
    temp_plot <-
      ggplot() +
      geom_line(aes(
        y = SEIRD_pred$I1_increase[-1] * test_fraction,
        x = SEIRD_pred$date[-1],
        color = "rseir"
      )) +
      geom_point(aes(y = obs_data_kit$I1_obs, x = reference_date + obs_data_kit$I1_obsdays,color = "smoothed_observed")) +
      geom_line(aes(x = pyseir_res$Date[-1], y = pyseir_res$I1_increase[-1],color =
                  "pyseir")) +
      labs(
        x = "Date",
        y = "I1_increase",
        title = paste0(
          state_ac,
          " I1_increase, Predicted*test_fraction VS observed Vs pyseir"
        ),
        subtitle = paste0(
          "number of phases=",
          number_of_phase,
          "   test_fraction=",
          test_fraction
        ),
        color = "source"
      ) +
      scale_color_manual(values = c(
        "smoothed_observed" = "blue",
        "rseir" = "red",
        "pyseir" = "green"
      ))
    
    temp_plot <- Add_timestamp_vline(temp_plot)
    ggsave(
      glue("{country}_{state_ac}_I1_increase_rseir_vs_pyseir.png"),
      plot = temp_plot,
      path = plots_by_state_path
    )
    I1_plot <- temp_plot
    
  }
  
  ## the final I1 and hosp compare plot
  ggsave(
    glue("{country}_{state_ac}_I1_and_hosp.png"),
    plot = I1_plot + hosp_plot,
    path = plots_by_state_path,
    width = 16,
    height = 8,
    units = "in"
  )
  
  ## the SEIRD plots
  {
    ## all variables in one plot, with log scale
    {
      temp_plot <- SEIRD_pred %>%
        pivot_longer(
          cols = c("S", "E", "I1", "I2", "I3", "R", "D"),
          names_to = "variables",
          values_to = "values"
        ) %>%
        select(date, variables, values) %>%
        filter(values >= 1) %>%
        ggplot() +
        geom_line(aes(
          x = date,
          y = log10(values),
          color = variables
        )) +
        labs(
          title = paste0("SEIRD for ", state_ac),
          subtitle = paste0("number of phases: ", number_of_phase)
        )
      
      temp_plot <- Add_timestamp_vline(temp_plot)
      
      ggsave(
        glue("{country}_{state_ac}_SEIRD_variables_with_log.png"),
        plot = temp_plot,
        path = plots_by_state_path
      )
    }
    
    ## the current value of all variables, ploted one by one
    {
      for (v_name in c("S", "E", "I1", "I2", "I3", "R", "D"))
      {
        temp_plot <- ggplot(SEIRD_pred) +
          geom_line(aes(x = date, y = SEIRD_pred[[v_name]]), color = "red") +
          labs(
            x = "Date",
            y = paste0(v_name, "_current"),
            title = paste0(state_ac, "Current value of ", v_name),
            subtitle = paste0("number of phases=", number_of_phase)
          )
        
        temp_plot <- Add_timestamp_vline(temp_plot)
        ggsave(
          glue("{country}_{state_ac}_{v_name}_current.png"),
          plot = temp_plot,
          path = plots_by_state_path
        )
      }
    }
    
    ### 20201208 mix_datasource_update. Add the plots requested by Chen
    {
      color_map <-
        c(
          "Susceptible (S)" = "black",
          "Recovered (R)" = "green",
          "Mild infected (I1)" = "red",
          "Hospitalized infected (I2)" = "orange",
          "ICU infected (I3)" = "brown",
          "Exposed (E)" = "blue",
          "Deceased (D)" = "purple"
        )
      
      ## all variables in one plot, without log scale
      {
        temp_plot <- ggplot(SEIRD_pred, aes(x = date)) +
          geom_line(aes(y = S, color = "Susceptible (S)")) +
          geom_line(aes(y = E, color = "Exposed (E)")) +
          geom_line(aes(y = I1, color = "Mild infected (I1)")) +
          geom_line(aes(y = I2, color = "Hospitalized infected (I2)")) +
          geom_line(aes(y = I3, color = "ICU infected (I3)")) +
          geom_line(aes(y = R, color = "Recovered (R)")) +
          geom_line(aes(y = D, color = "Deceased (D)")) +
          labs(
            x = "Date",
            y = "Number of people",
            title = glue("SEIRD of {state_ac}"),
            color = "Legend",
            caption = glue("created at {t_end}")
          ) +
          scale_color_manual(values = color_map)
        
        temp_plot <- Add_timestamp_vline(temp_plot)
        
        ggsave(
          filename = glue("{country}_{state_ac}_SEIRD_variables.png"),
          plot = temp_plot,
          path = plots_by_state_path
        )
      }

      ## no S
      {
        temp_plot <- ggplot(SEIRD_pred, aes(x = date)) +
          geom_line(aes(y = E, color = "Exposed (E)")) +
          geom_line(aes(y = I1, color = "Mild infected (I1)")) +
          geom_line(aes(y = I2, color = "Hospitalized infected (I2)")) +
          geom_line(aes(y = I3, color = "ICU infected (I3)")) +
          geom_line(aes(y = R, color = "Recovered (R)")) +
          geom_line(aes(y = D, color = "Deceased (D)")) +
          labs(
            x = "Date",
            y = "Number of people",
            title = glue("SEIRD of {state_ac} withour S"),
            color = "Legend",
            caption = glue("created at {t_end}")
          ) +
          scale_color_manual(values = color_map)
        
        temp_plot <- Add_timestamp_vline(temp_plot)
        
        ggsave(
          filename = glue("{country}_{state_ac}_SEIRD_variables_without_S.png"),
          plot = temp_plot,
          path = plots_by_state_path
        )
      }

  
      ## no S and R
      {
        temp_plot <- ggplot(SEIRD_pred, aes(x = date)) +
          geom_line(aes(y = E, color = "Exposed (E)")) +
          geom_line(aes(y = I1, color = "Mild infected (I1)")) +
          geom_line(aes(y = I2, color = "Hospitalized infected (I2)")) +
          geom_line(aes(y = I3, color = "ICU infected (I3)")) +
          geom_line(aes(y = D, color = "Deceased (D)")) +
          labs(
            x = "Date",
            y = "Number of people",
            title = glue("SEIRD of {state_ac} without S and R"),
            color = "Legend",
            caption = glue("created at {t_end}")
          ) +
          scale_color_manual(values = color_map)
        
        temp_plot <- Add_timestamp_vline(temp_plot)
        
        ggsave(
          filename = glue(
            "{country}_{state_ac}_SEIRD_variables_without_S_and_R.png"
          ),
          plot = temp_plot,
          path = plots_by_state_path
        )
      }

    }
    
  }


}
### the code below is for debug
## replot
# make_plots(state_ac = state)

### create those goddame folder in case git wipe them
{
  folder_list <-
    c(
      "outputs/CA/SEIRD_data",
      "outputs/CA/plots_by_state",
      "outputs/CA/temp_rds",
      "outputs/US/SEIRD_data",
      "outputs/US/plots_by_state",
      "outputs/US/temp_rds",
      "so_far_the_best/CA/SEIRD_data",
      "so_far_the_best/CA/plots_by_state",
      "so_far_the_best/CA/temp_rds",
      "so_far_the_best/US/SEIRD_data",
      "so_far_the_best/US/plots_by_state",
      "so_far_the_best/US/temp_rds"
    )
  for (folder in folder_list) {
    if (!file.exists(folder))
      dir.create(folder, recursive = TRUE)
  }
}


### 20201103 pin policy update
# dd_to_supt <- function(dd_para)
# {
#   supt_para <- dd_para[-(1:3)]
#   supt_para[2] <- dd_para[5]-dd_para[3] ## lockdown,subtract by t0
#   supt_para[4] <- dd_para[7]-dd_para[5] ## reopen, to
#   
#   if(supt_para[2]<0 || supt_para[4]<0)
#   {
#     print("warning: negaitive duration")
#   }
#   return(supt_para)
# }

dd_to_supt <- function(dd_para)
{
  supt_para <- dd_para[-(1:3)]
  
  if (number_of_phase >= 2) {
    supt_para[2] <- dd_para[5] - dd_para[3]
    if (supt_para[2] < 0)
    {
      print("warning: negaitive duration")
    }
  }
  
  if (number_of_phase >= 3)
  {
    supt_para[4] <- dd_para[7] - dd_para[5]
    if ( supt_para[4] < 0)
    {
      print("warning: negaitive duration")
    }
  }
  
  if (number_of_phase >= 4)
  {
    supt_para[6] <- dd_para[9] - dd_para[7]
    if ( supt_para[6] < 0)
    {
      print("warning: negaitive duration")
    }
  }
  return(supt_para)
}

check_for_update_1m3f <- function(force=F,skip=F)
{
  previous_update_time <-
    readRDS("inputs/observed_timerseries_dataset/f_1m3f_dataset/previous_update_time.rds")
  time_diff <-
    as.numeric(Sys.time() - previous_update_time, units = "hours")
  if (force == T || skip != T && time_diff > 48) {
    cat("updating cached dataset","\n")
    file.copy(from = "inputs/observed_timerseries_dataset/f_1m3f_dataset/US_timeseries.csv",
              to = "inputs/observed_timerseries_dataset/f_1m3f_dataset/out_of_date",
              overwrite = T)
    file.copy(from = "inputs/observed_timerseries_dataset/f_1m3f_dataset/CA_timeseries.csv",
              to = "inputs/observed_timerseries_dataset/f_1m3f_dataset/out_of_date",
              overwrite = T)
    download.file(url = "https://instant.1point3acres.com/v1/api/coronavirus/us/cases?token=K38mXWhI", destfile = "US_timeseries.csv")
    download.file(url = "https://instant.1point3acres.com/v1/api/coronavirus/canada/cases?token=K38mXWhI", destfile = "CA_timeseries.csv")
    
    current_time <- Sys.time()
    saveRDS(current_time,"inputs/observed_timerseries_dataset/f_1m3f_dataset/previous_update_time.rds")
  } else {
    cat("using the cached dataset","\n")
  }
}


```

## for debug
```{r}
for (state_ac in state) {
  make_plots(state_ac)
  print(state_ac)
}
beep()

temp_pred <- readRDS(file.choose())

## create initial_values.csv and best_record.csv
{
  write_csv(state_info,
            glue("inputs/state_info/{country}_state_info.csv"))
  write_csv(temp,
            glue(
              "inputs/initial_value_and_best_record/{country}_initial_values.csv"
            ))
  write_csv(temp2,
            glue(
              "inputs/initial_value_and_best_record/{country}_best_record.csv"
            ))
  
  temp <- CA_state_info %>%
    select(-population) %>%
    mutate(
      test_fraction = 0.1,
      hosp_fraction = 0.7,
      t0_date = parse_date("2020-03-01"),
      R0 = 3.4,
      p1_to_p2_date = parse_date("2020-04-01"),
      eps2 = 0.3,
      p2_to_p3_date = parse_date("2020-06-15"),
      eps3 = 0.3,
      p3_to_p4_date = parse_date("2020-10-01"),
      eps4 = 0.5
    )
  temp2 <- temp %>%
    mutate(
      beta_1 = 0,
      beta_2 = 0,
      beta_3 = 0,
      beta_4 = 0,
      case_and_hosp_score = 1e10,
      death_score = 1e10,
      time = Sys.time()
    )
}

## so_far_the_best replot
for (state_ac in state) {
  rds_folder <- glue("so_far_the_best/{country}/temp_rds/{state_ac}")
  make_plots(state_ac,Sys.time(),rds_folder)
  print(state_ac)
}

## aggregating plot file for inspection
{
  move_plots <- function(origin_folder,re_exp,target_folder)
  {
    file_path <-
      list.files(
        path = origin_folder,
        pattern = re_exp,
        full.names = T,
        recursive = T
      )
    
    if(!dir.exists(target_folder)){
      dir.create(target_folder,recursive = T)
    }
    
    for (file in file_path) {
      file.copy(from = file,to=target_folder,overwrite = T)
    }
  }
  
  moving_list <- c(
    "so_far_the_best/US/plots_by_state","*I1_and_hosp.png",       "so_far_the_best/US/inspection/I1_and_hosp",
    "so_far_the_best/US/plots_by_state","*D_increase_zoomed.png", "so_far_the_best/US/inspection/D_increase",        
    "so_far_the_best/US/plots_by_state","*beta1t_and_dd_para.png","so_far_the_best/US/inspection/beta1t",         
    "so_far_the_best/CA/plots_by_state","*I1_and_hosp.png",       "so_far_the_best/CA/inspection/I1_and_hosp",
    "so_far_the_best/CA/plots_by_state","*D_increase_zoomed.png", "so_far_the_best/CA/inspection/D_increase",         
    "so_far_the_best/CA/plots_by_state","*beta1t_and_dd_para.png","so_far_the_best/CA/inspection/beta1t"              
  )
  for (i in 1:6) {
    move_plots(moving_list[1 + 3 * (i - 1)], moving_list[2 + 3 * (i - 1)], moving_list[3 +
                                                                                         3 * (i - 1)])
  }
}

download.file(url = "https://instant.1point3acres.com/v1/api/coronavirus/us/cases?token=K38mXWhI",destfile = "outputs/temp.csv")

```


## the main script
```{r}
#### setup
### PENDING: explain the parameters

## target setup
country <- "CA"  # "US" or "CA"

# select state 
# available state list for CA:
# c("AB","BC","MB","NL","NS","ON","QC") # 20200105 remove NB, SK because of low infection increase (<20)
# available state list for US:
# c("AL","AK","AZ","AR","CA","CO","CT","DE","DC","FL","GA","HI","ID","IL","IN","IA","KS","KY","LA","ME","MD","MA","MI","MN","MS","MO","MT","NE","NV","NH","NJ","NM","NY","NC","ND","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VT","VA","WA","WV","WI","WY")
state <- "BC" #"BC" #c("IL","NY", "FL", "CA") # c("CA")

## basic setup
suppressMessages(state_info <-
                   read_csv(glue(
                     "inputs/state_info/{country}_state_info.csv"
                   )))
# reference_date is needed in optimizing the t0, the beginning date of the pandemic. Any date before the pandemic will work
reference_date <- parse_date("2020-01-01")
# the duration of the transition period
days_between_phases <- 14
# smoothing window radius. window_radius = 1 is equal to a window of 3
window_radius <- 3
# the total length of the SEIRD timeseries, include the past and the future
total_days <- 365
# set this to a past date to get a "past prediction" 
# "past prediction" feature is deprecated. Do not change it.
last_date_with_available_data <- Sys.Date()

## for sampling parameter
n_sample <- 5000

### 20201208 mix_datasource_update
# "datasource switching" feature is deprecated. Do not change it.
if (country=="US"){
  case_datasource <- "f_1m3f"          # valid options:"can_US","esri_CA","f_1m3f"
  hosp_datasource <- "can_US"             # valid options:"can_US","esri_CA"
  death_datasource <-  "f_1m3f"         # valid options:"can_US","esri_CA","f_1m3f"
} else if (country == "CA") {
  case_datasource <- "f_1m3f"          # valid options:"can_US","esri_CA","f_1m3f"
  hosp_datasource <- "esri_CA"             # valid options:"can_US","esri_CA"
  death_datasource <- "f_1m3f"         # valid options:"can_US","esri_CA","f_1m3f"
}


## choose the observed SEIRD variables that are used in the score calculation
## this feature is deprecated. do not change it
use_case <- T
use_hosp <- T 
use_death <- F 

## for data-driven parameter
use_best_result <- F
# use date (pin-policy update) or use duration?
## this feature is deprecated. do not change it
overwrite_initial_dd_parameter <- T  ### broken, a change in build_beta_t is leak, stay true please
# the number of time phase.
# this feature is deprecated. do not change it
number_of_phase <- 4
# the optimization radius of the policy date
# larger value will produce unstable output. Should consider the initial value of pi_to_pj before changing or it might trigger the "negative duration error" 
opt_radius_of_policydate <- 14


## execution. Display the runtime at the end
print(system.time(rpyseir()))

## prompt. play sound when finished
beep(sound = 1, expr = NULL)
```




